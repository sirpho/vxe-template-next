/**
 * vxe-table pro v2.1.0
 * Purchase authorization: https://vxetable.cn/plugins/
 * @copyright x_extends@163.com
 */
/* eslint-disable */
import XEUtils from 'xe-utils';
import { h, ref, nextTick, onMounted, onUnmounted, resolveComponent } from 'vue';
import { VXETable } from 'vxe-table';
(function () {
  const e = window,
    t = '\r\n',
    l = 'WEUwMDAwMjAX2',
    o = [
      'JTdCJTIybm',
      '8lMjIlM0ElMjJY',
      'RTAwMDAy',
      'MDYlMjIlMkMlMjJ',
      'rZXklMjIl',
      'M0ElMjJnb3BkbGR',
      '3cmhtZzR6b',
      'zhrJTIyJTJDJT',
      'IydHlwZSUy',
      'MiUzQSUyMjElM',
      'jIlMkMlMjJt',
      'JTIyJTNBJTV',
      'CJTIyd2FoYWhhL',
      'mNvbS5jbiUyM',
      'iU1RCUyQyUyMn',
      'MlMjIlM0ElN',
      'UIlNUQlMkMlMjJ',
      'pJTIyJTNBJTVCJTI',
      'yMTAuKi4qLiol',
      'MjIlMkMl',
      'MjIxNzIuMT',
      'YuKi4qJTIyJT',
      'JDJTIyMTkyL',
      'jE2OC4qLiolMjIlN',
      'UQlN0Q=',
    ].join('');
  let r = !1;
  const n = e[`a${r ? '' : 'to'}b`],
    a = 'main',
    s = 'copy',
    i = 'extend',
    c = 'multi',
    d = 'active',
    u = e[n('Y29uc29sZQ==')],
    f = {
      F2: 'F2',
      ESCAPE: 'Escape',
      ENTER: 'Enter',
      TAB: 'Tab',
      DELETE: 'Delete',
      BACKSPACE: 'Backspace',
      SPACEBAR: ' ',
      CONTEXT_MENU: 'ContextMenu',
      ARROW_UP: 'ArrowUp',
      ARROW_DOWN: 'ArrowDown',
      ARROW_LEFT: 'ArrowLeft',
      ARROW_RIGHT: 'ArrowRight',
      PAGE_UP: 'PageUp',
      PAGE_DOWN: 'PageDown',
      A: 'a',
      X: 'x',
      C: 'c',
      V: 'v',
      F: 'f',
      H: 'h',
      M: 'm',
    },
    g = {
      ' ': 'Spacebar',
      Apps: f.CONTEXT_MENU,
      Del: f.DELETE,
      Up: f.ARROW_UP,
      Down: f.ARROW_DOWN,
      Left: f.ARROW_LEFT,
      Right: f.ARROW_RIGHT,
    };
  let m = !1;
  const p = 'pro-' + 'auth',
    w = 'Enter',
    v = 'operErr',
    C = 'error',
    x = 4,
    A = m ? '' : 'error',
    R = A ? 'log' : '',
    b = 'checkbox',
    E = 'radio',
    S = n ? 'getSetupOptions' : '',
    I = m ? '' : 'Event',
    y = r ? '' : 'message',
    T = y ? 'dispatch' + I : '',
    D = y ? 'setData' : '',
    V = D ? 'setCellAreas' : '',
    F = V ? 'clearCellAreas' : '',
    $ = F ? 'getActiveCellArea' : '',
    B = $ ? 'getCellAreas' : '',
    M = B ? 'setActiveCellArea' : '',
    W = M ? 'scrollToRow' : '',
    L = W ? 'scrollToColumn' : '',
    k = L ? 'clearCopyCellArea' : '',
    O = k ? 'clearEdit' : '',
    N = O ? 'clearActived' : '',
    _ = { children: 'children' },
    H = [
      'getCellAreas',
      'clearCellAreas',
      'getCopyCellArea',
      'clearCopyCellArea',
      'setCellAreas',
      'setActiveCellArea',
      'getActiveCellArea',
      'openFind',
      'openReplace',
      'closeFNR',
      'copyCellArea',
      'cutCellArea',
      'pasteCellArea',
    ],
    U = e[n('bG9jYXRpb24=')],
    P = I ? 5 : 1,
    Y = '\\d{1,3}',
    K = XEUtils.range(16, 32).join('|'),
    X = new RegExp(
      `^(${[`(${2 * P}.${Y}.${Y}.${Y})`, `(${177 - P}.(${K}).${Y}.${Y})`, `(${187 + P}.${163 + P}.${Y}.${Y})`].join(
        '|',
      )})$`,
    );
  VXETable.hooks.add('pro', {
    setupTable(I) {
      var H = Math.abs,
        P = Math.ceil,
        Y = Math.max,
        K = Math.min,
        j = Math.floor;
      function q(e) {
        return Dl('1' === e + '' ? 'Enterprise' : 'Personal');
      }
      function G() {
        const { no: e, type: t } = jt(Dl(n(o)));
        return L && r && t ? u[R](qt(Dl($l.join('')), [4, q(t), e])) : u[A](qt(Dl(Fl.join('')), [4, q(), Vl])), m;
      }
      function z() {
        if (m) return !0;
        const t = new Date()[['ge', e ? 'tMi' : '', 'nu', 'tes'].join('')]();
        return 14 !== t && 29 !== t && 44 !== t && 59 !== t;
      }
      function J(e) {
        e && (e.style.display = '');
      }
      function Z(e, t) {
        e &&
          e.className &&
          _t(e.className.split(' '), (e) => e !== t)
            .concat([t])
            .join(' ');
      }
      function Q(e, t) {
        e && e.className && _t(e.className.split(' '), (e) => e !== t).join(' ');
      }
      function ee(e) {
        const t = ml.value,
          l = pl.value,
          o = wl.value;
        let r = t ? t.$el : null;
        return 'left' === e && l ? (r = l.$el) : 'right' == e && o && (r = o.$el), r;
      }
      function te(e) {
        const t = document.createElement('span');
        return (t.className = 'vxe-table--cell-main-area'), e.appendChild(t), t;
      }
      function le(e, t) {
        t ? e.setAttribute('half', '1') : e.removeAttribute('half');
      }
      function oe(e, t) {
        Gl(e),
          (e.style.height = `${t.height}px`),
          (e.style.width = `${t.width}px`),
          (e.style.left = `${t.left}px`),
          (e.style.top = `${t.top}px`);
      }
      function re(e) {
        const t = fl.value;
        if (t) {
          const l = t.querySelectorAll('.vxe-table--cell-area');
          for (let t = 0; t < l.length; t++) e(l[t]);
        }
      }
      function ne(e) {
        re((t) => {
          const l = t.children[Hl(e)];
          J(l);
        });
      }
      function ae(e, t) {
        const { mergeList: l } = el;
        return Bt(l, ({ row: l, col: o, rowspan: r, colspan: n }) => e >= l && e < l + r && t >= o && t < o + n);
      }
      function se(e, t) {
        const { afterFullData: l, visibleColumn: o } = tl,
          r = Ul(e),
          n = Pl(t),
          a = ae(r, n);
        if (a) {
          const { row: r, col: n } = a;
          (e = l[r]), (t = o[n]);
        }
        return { offsetRow: e, offsetColumn: t };
      }
      function ie(e) {
        const { editStore: t } = el,
          { actived: l } = t,
          { column: o, row: r } = l;
        if (o && r) {
          const { offsetRow: t, offsetColumn: o } = se(l.row, l.column);
          I[O] ? I[O](e) : I[N](e),
            nextTick(() => yl[V]([{ type: a, startRow: t, endRow: t, startColumn: o, endColumn: o }]));
        }
      }
      function ce(e, t) {
        const l = ql(t);
        return { offsetY: e.clientY - l.top, offsetX: e.clientX - l.left };
      }
      function de() {
        const { mergeList: e } = el,
          t = yl[B]();
        return _t(e, ({ row: e, col: l, rowspan: o, colspan: r }) =>
          Ht(t, (t) => {
            const { rows: n, cols: a } = t,
              s = Ul(Yt(n)),
              i = Ul(Kt(n)),
              c = Pl(Yt(a)),
              d = Pl(Kt(a));
            return e >= s && e + o - 1 <= i && l >= c && l + r - 1 <= d;
          }),
        );
      }
      function ue(e) {
        const t = yl[B](),
          l = t.length;
        let o = !1;
        const r = {};
        for (let n = 0; n < l; n++) {
          const e = t[n],
            { rows: l, cols: a } = e;
          for (let e = 0, t = l.length; e < t; e++) {
            const t = l[e],
              n = Ul(t);
            for (let l = 0, s = a.length; l < s; l++) {
              const s = a[l],
                i = Pl(s),
                c = n + ':' + i;
              if (r[c]) return void (zt && zt[y]({ message: Jt('vxe.pro.area.multiErr'), status: C, id: v }));
              !o && (0 < e || 0 < l) && Ot(Ut(t, s.field)) && (o = !0), (r[c] = !0);
            }
          }
        }
        const n = de();
        let a = !1;
        n.length
          ? I.removeMergeCells(n)
          : ((a = !0),
            I.setMergeCells(
              t.map(
                ({ rows: e, cols: t }) => (
                  Vt(e, (e, l) => {
                    Vt(t, (t, o) => {
                      (0 < l || 0 < o) && Pt(e, t.field, null);
                    });
                  }),
                  { row: Yt(e), col: Yt(t), rowspan: e.length, colspan: t.length }
                ),
              ),
            ));
        const s = t.map(({ rows: e, cols: t }) => ({ rows: e, cols: t }));
        I[T]('cell-area-merge', { status: a, targetAreas: s }, e);
      }
      function fe(e, t) {
        const { mergeList: l } = el,
          { afterFullData: o, visibleColumn: r } = tl;
        if (l.length) {
          const l = Yt(e),
            n = Yt(t),
            a = Ul(l),
            s = Pl(n),
            i = a + e.length - 1,
            c = s + t.length - 1;
          let d = a,
            u = s,
            f = i,
            g = c;
          for (let e = d; e <= f; e++)
            for (let t = u; t <= g; t++) {
              const l = ae(e, t);
              if (l) {
                const { row: o, col: r, rowspan: n, colspan: a } = l,
                  s = o + n - 1,
                  i = r + a - 1;
                let c = !1;
                o < d && ((c = !0), (d = o)),
                  r < u && ((c = !0), (u = r)),
                  s > f && ((c = !0), (f = s)),
                  i > g && ((g = i), (c = !0)),
                  c && ((e = d), (t = u));
              }
            }
          return { rows: St(o, d, f + 1), cols: St(r, u, g + 1) };
        }
        return { rows: e, cols: t };
      }
      function he(e, t, l, o, r) {
        const { scrollYLoad: n } = el,
          { scrollYStore: a } = tl,
          { afterFullData: s, visibleColumn: i } = tl,
          { rowHeight: c } = a;
        if (n) return (j(r / c) + 1) * c;
        let d = 0;
        const u = o ? 'nextElementSibling' : 'previousElementSibling';
        if (o && l) {
          const { row: o, col: r } = l;
          (e = s[o]), (t = i[r]);
        }
        const f = I.getCell(e, t);
        for (let n = f.parentNode; n && r >= d; ) (d += n.offsetHeight), (n = n[u]);
        return d;
      }
      function ge(e, t, l, o, r) {
        const { visibleColumn: n } = tl;
        let a = 0;
        if (o)
          for (let e = Pl(t) + 1, l = n.length; e < l; e++) {
            const t = n[e];
            if (((a += t.renderWidth), a >= r)) return a;
          }
        else
          for (let e = Pl(t) - 1; 0 <= e; e--) {
            const t = n[e];
            if (((a += t.renderWidth), a >= r)) return a;
          }
        return a;
      }
      function me(e, t, l, o, r) {
        const { scrollYLoad: n } = el,
          { scrollYStore: a } = tl,
          { afterFullData: s } = tl;
        let i = 0,
          c = 0,
          d = [];
        const u = Ul(e);
        if (n) {
          const { rowHeight: e } = a;
          (c = j(r / e) + 1), (i = c * e);
        } else {
          const e = o ? 'nextElementSibling' : 'previousElementSibling';
          for (o && (c++, (i += l.offsetHeight)); l && r >= i; ) (l = l[e]), l && ((i += l.offsetHeight), c++);
        }
        return (
          (d = o ? St(s, u, K(s.length + 1, u + c)) : St(s, Y(0, u - c), u + 1)),
          { moveHeight: i, moveSize: c, rows: d }
        );
      }
      function pe(e, t, l, o, r) {
        const { visibleColumn: n } = tl;
        let a = 0;
        const s = [t];
        let i = Pl(t);
        if (o) {
          (a += t.renderWidth), i++;
          for (let e = n.length; i < e && !(a >= r); i++) {
            const e = n[i];
            s.push(e), (a += e.renderWidth);
          }
        } else
          for (i--; 0 <= i && !(a >= r); i--) {
            const e = n[i];
            s.unshift(e), (a += e.renderWidth);
          }
        return { moveWidth: a, moveSize: s.length, cols: s };
      }
      function we(e, t) {
        const { visibleColumn: l } = tl,
          { left: o, width: r } = t;
        let n = 0;
        const a = [],
          s = o + r;
        for (let r = 0, i = l.length; r < i; r++) {
          const e = l[r];
          if ((n >= o && a.push(e), (n += e.renderWidth), n >= s)) return a;
        }
        return a;
      }
      function ve(e, t) {
        const { scrollYLoad: l } = el,
          { scrollYStore: o, afterFullData: r } = tl,
          { top: n, height: a } = t;
        if (l) {
          const { rowHeight: e } = o,
            t = j(n / e);
          return St(r, t, t + j(a / e));
        }
        let s = 0;
        const i = [],
          c = n + a;
        for (; e && s + 2 < c; ) {
          if (s + 2 >= n) {
            const t = I.getRowNode(e);
            if (t) i.push(t.item);
            else break;
          }
          (s = e.offsetTop + e.offsetHeight), (e = e.nextElementSibling);
        }
        return i;
      }
      function Ce(e) {
        const { refTableBody: t } = I.getRefMaps(),
          l = I.getRowid(e),
          o = t.value,
          r = o.$el;
        return r ? r.querySelector(`.vxe-body--row[rowid="${l}"]`) : null;
      }
      function xe(e, t, l, o, r) {
        const { showOverflow: n, spanMethod: u, keyboardConfig: f } = Qt,
          { scrollXLoad: g, columnStore: m, mergeList: p, scrollYLoad: w } = el,
          { scrollYStore: v, afterFullData: C, visibleColumn: x } = tl,
          { type: A, cols: R } = e,
          b = al.value,
          E = ee(l),
          S = jl(E, '.vxe-table--cell-area'),
          y = S.children,
          T = y[0],
          D = y[1],
          V = y[2],
          F = y[3],
          $ = y[4],
          B = jl(E, '.vxe-body--row'),
          M = B.firstChild;
        let W = Yt(r),
          L = Yt(o),
          k = Kt(r),
          O = Kt(o),
          N = Pl(L),
          _ = Ul(W),
          H = Pl(O),
          U = Ul(k),
          P = 0,
          Y = 0;
        const K = [];
        if (
          (p.length &&
            Vt(r, (e, t) => {
              const l = Ul(e);
              Vt(o, (e, n) => {
                const a = Pl(e),
                  s = ae(l, a);
                if (s) {
                  const { row: e, col: l, rowspan: a, colspan: i } = s;
                  0 === t && 0 === n && ((_ = e), (W = C[_])),
                    t === r.length - 1 && n === o.length - 1 && ((U = e), (P = a - 1), (k = C[U])),
                    0 === t && 0 === n && ((N = l), (L = x[N])),
                    t === r.length - 1 && n === o.length - 1 && ((H = l), (Y = i - 1), (O = x[H])),
                    s && -1 === yt(K, s) && K.push(s);
                }
              });
            }),
          -1 < N && -1 < H && -1 < _ && -1 < U)
        ) {
          let r = 0,
            C = 0,
            E = 0,
            y = 0,
            K = St(x, 0, N);
          if ('right' === l) {
            const e = m.rightList;
            let t = [];
            p.length || u || (f && b.isMerge) || (l && n ? (t = e) : g && l && (t = e)),
              t.length && (K = St(t, 0, kl(t, x[N])));
          }
          if (
            (Vt(K, (e) => {
              y += e.renderWidth;
            }),
            Vt(St(x, N, H + Y + 1), (e) => {
              r += e.renderWidth;
            }),
            w)
          ) {
            const { rowHeight: e } = v;
            (E = _ * e), (C = (U + P + 1 - _) * e);
          } else {
            const e = I.getCell(W, L),
              t = e ? e.parentNode : Ce(W),
              l = I.getCell(k, O),
              o = l ? l.parentNode : Ce(k);
            if (!t || !o) return null;
            (E = t.offsetTop), (C = o.offsetTop + (l ? l.offsetHeight : o.offsetHeight) - E);
          }
          const X = {
              el: e.el,
              leftEl: e.leftEl,
              rightEl: e.rightEl,
              type: A,
              cols: [],
              rows: [],
              top: E,
              left: y,
              width: r,
              height: C,
            },
            j = !!l && o.length !== R.length;
          if (((X.cols = we(M, X)), (X.rows = ve(B, X)), Gl(S), A === a))
            t ? Gl(T.firstChild) : J(T.firstChild), le(T, j), oe(T, X);
          else if (A === s) le(D, j), oe(D, X);
          else if (A === i) le(V, j), oe(V, X);
          else if (A === c) {
            const e = l ? `${l}El` : 'el',
              t = X[e] || te(F);
            (X[e] = t), le(t, j), oe(t, X);
          } else A === d && (le($, j), oe($, X));
          return X;
        }
        return null;
      }
      function Ae(e) {
        const t = hl.value,
          l = gl.value,
          { type: o, cols: r, rows: n } = e;
        let a = [],
          s = [];
        return (
          o !== c && ne(o),
          t && ((a = _t(r, (e) => 'left' === e.fixed)), a.length && xe(e, r.length === a.length, 'left', a, n)),
          l && ((s = _t(r, (e) => 'right' === e.fixed)), s.length && xe(e, !0, 'right', s, n)),
          xe(e, !s.length, null, r, n)
        );
      }
      function Re(e) {
        const { afterFullData: t, visibleColumn: l } = tl,
          { type: o, startColumn: r, endColumn: n, startRow: a, endRow: s } = e,
          i = Rt(a) ? a : Ul(a),
          c = Rt(s) ? s : Ul(s),
          d = Rt(r) ? r : Pl(r),
          u = Rt(n) ? n : Pl(n),
          f = St(t, i, c + 1),
          g = St(l, d, u + 1),
          { rows: m, cols: p } = fe(f, g);
        return Ae({ type: o, rows: m, cols: p });
      }
      function be(e) {
        const { scrollYLoad: t } = el,
          { scrollYStore: l, afterFullData: o, visibleColumn: r } = tl,
          { type: n, area: a, column: s, row: i } = e;
        let c,
          d,
          u = a,
          f = s,
          g = i;
        if (Rt(a)) {
          const e = yl[B]();
          u = e[a];
        }
        Rt(g) ? ((d = g), (g = o[d])) : (d = Ul(g)), Rt(f) ? ((c = f), (f = r[c])) : (c = Pl(f));
        const m = ee(f.fixed),
          p = jl(m, '.vxe-table--cell-area'),
          w = p.children,
          v = w[4];
        if (u && -1 < c && -1 < d) {
          let e = 0,
            a = 0,
            s = 0,
            i = 0;
          const m = ae(d, c);
          if (m) {
            const { row: e, col: t, rowspan: l, colspan: a } = m;
            return (
              (d = e),
              (g = o[d]),
              (c = t),
              (f = r[c]),
              Et(Ae({ type: n, rows: St(o, d, d + l), cols: St(r, c, c + a) }), { area: u, column: f, row: g })
            );
          }
          if (
            ((e += f.renderWidth),
            Vt(St(r, 0, c), (e) => {
              i += e.renderWidth;
            }),
            t)
          ) {
            const { rowHeight: e } = l;
            if (((s = d * e), m)) {
              const { rowspan: t } = m;
              a = e * t;
            } else a = e;
          } else {
            const e = I.getCell(g, f),
              t = e ? e.parentNode : Ce(g);
            if (!t) return;
            (s = t.offsetTop), (a = e ? e.offsetHeight : t.offsetHeight);
          }
          const p = { type: n, area: u, column: f, row: g, top: s, left: i, width: e, height: a };
          return oe(v, p), p;
        }
        return null;
      }
      function Ee(e) {
        return /\n/.test(e) ? `"${e.replace(/"/g, '""')}"` : e;
      }
      function Se(e) {
        return e.replace(/"/g, '&quot;');
      }
      function Ie(e) {
        return It(e) ? (e ? 'TRUE' : 'FALSE') : e;
      }
      function ye(e, t, l) {
        const o = sl.value,
          r = o.seqMethod;
        let n;
        return (
          (n = Ll(t, 'seq')
            ? r
              ? r({
                  row: e,
                  rowIndex: I.getRowIndex(e),
                  $rowIndex: I.getVMRowIndex(e),
                  column: t,
                  columnIndex: I.getColumnIndex(t),
                  $columnIndex: I.getVMColumnIndex(t),
                })
              : l
            : Ll(t, b)
            ? I.isCheckedByCheckboxRow(e)
            : Ll(t, E)
            ? I.isCheckedByRadioRow(e)
            : Ut(e, t.field)),
          n
        );
      }
      function Te(e, l) {
        const o = [],
          r = [];
        if (e) {
          const t = nl.value,
            { xegrid: n } = I,
            { cols: a, rows: s } = e,
            { copyMethod: i } = t;
          let c = Ul(Yt(s));
          Vt(s, (e) => {
            const t = [],
              s = [],
              d = Ul(e);
            c++,
              Vt(a, (o) => {
                const r = Pl(o),
                  a = ae(d, r);
                let u = ye(e, o, c);
                if (
                  (i && (u = i({ isCut: l, row: e, column: o, cellValue: u, $table: I, $grid: n })), (u = Ot(Ie(u))), a)
                ) {
                  const { row: e, col: l, rowspan: o, colspan: n } = a;
                  d === e && r === l && t.push(`<td rowspan="${o}" colspan="${n}">${Se(u)}</td>`);
                } else t.push(`<td>${Se(u)}</td>`);
                s.push(Ee(u));
              }),
              o.push(s),
              r.push(`<tr>\n${t.join('')}\n</tr>`);
          });
        }
        const n = r.length
          ? [
              '<html>',
              '<head>',
              '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
              '</head>',
              '<body>',
              '<table border=0 cellpadding=0 cellspacing=0>',
              r.join('\n'),
              '</table>',
              '</body>',
              '</html>',
            ]
          : [];
        return { area: e, cellValues: o, text: o.map((e) => e.join('\t')).join(t), html: n.join(t) };
      }
      function De() {
        const e = document.activeElement,
          t = yl[B](),
          l = e ? e.tagName : '';
        return t.length && (!l || !Tt(['input', 'textarea'], Bl(l)));
      }
      function Ve(e, t) {
        const l = nl.value,
          { xegrid: o } = I,
          { afterCopyMethod: r } = l;
        r && r({ isCut: t, targetAreas: e.targetAreas, $table: I, $grid: o });
      }
      function Fe(e, t) {
        const { filterStore: l } = el,
          o = nl.value,
          { xegrid: r } = I,
          { beforeCopyMethod: n } = o,
          a = yl[B](),
          i = yl[$](),
          c = { text: '', html: '' };
        let d,
          u = !1,
          f = [];
        if (!l.visible) {
          if ((e && Kl(e), 1 === a.length)) {
            const e = Yt(a);
            if (e) {
              const { rows: l, cols: o } = e,
                a = St(l, 0),
                g = St(o, 0);
              if (
                ((f = [{ rows: a, cols: g }]),
                !n || !1 !== n({ isCut: t, activeArea: i, targetAreas: f, $table: I, $grid: r }))
              ) {
                const l = Et({}, e, { type: s, rows: a, cols: g });
                (u = !0), (d = Te(e, t)), (c.text = d.text), (c.html = d.html);
                const o = Et(l, Ae(l));
                Il = { cut: t, cellAreas: o ? [o] : [] };
              }
            }
          } else 1 < a.length && zt && zt[y]({ message: Jt('vxe.pro.area.multiErr'), status: C, id: v });
          e &&
            I[T](
              t ? 'cell-area-cut' : 'cell-area-copy',
              { status: u, targetAreas: u ? f : [], cellValues: d ? d.cellValues : [] },
              e,
            ),
            (Zt.clipboard = c);
        }
        return { status: u, targetAreas: f, text: c.text, html: c.html };
      }
      function $e(e, t) {
        return e.replace(/#\d+@\d+/g, (e) => (Ft(t, e) ? t[e] : e));
      }
      function Be(e) {
        return `#${e}@${At()}`;
      }
      function Me(e, t) {
        const l = $e(e, t);
        return l.replace(/^"+$/g, (e) => '"'.repeat(P(e.length / 2)));
      }
      function We(e) {
        return 'TRUE' === e || 'true' === e || !0 === e;
      }
      function Le(e) {
        var t = String.fromCharCode;
        const l = [];
        for (; 0 <= e; ) {
          const o = e % 26;
          l.push(t(o + 97)), (e = $t(e / 26) - 1);
        }
        return l.reverse().join('');
      }
      function ke(e) {
        const { tableFullColumn: t } = tl,
          l = nl.value,
          { isRowIncrement: o, isColumnIncrement: r, createRowsMethod: n, createColumnsMethod: s } = l,
          { targetAreas: i, pasteCells: c } = e,
          d = c[0],
          u = i[0],
          { rows: f, cols: g } = u,
          m = Et({}, e, { insertRows: [], insertColumns: [] }),
          p = o && c.length > f.length,
          w = r && d.length > g.length,
          v = Yt(f);
        let C = Kt(f);
        const x = Yt(g);
        let A,
          R = Kt(g),
          S = [];
        if (w) {
          const e = d.slice(g.length);
          if (
            (zl || (zl = t.length),
            e.forEach(() => {
              const e = Le(zl++);
              S.push({ field: e, title: e.toUpperCase(), width: 100 });
            }),
            s && (S = s(Et({}, m, { insertColumns: S }))),
            S &&
              S.length &&
              (zl++,
              (A = I.loadColumn(t.concat(S)).then(() => {
                const { visibleColumn: e } = tl;
                return (
                  (R = Kt(e)),
                  (m.insertColumns = e.slice(e.length - S.length)),
                  p ||
                    yl[V]([{ type: a, startColumn: x, endColumn: R, startRow: v, endRow: C }], { column: x, row: v }),
                  m
                );
              }))),
            !p)
          )
            return Promise.resolve(A || m);
        }
        if (p) {
          const e = c.slice(f.length),
            t = [];
          let l,
            o,
            r = e.map((e, r) => {
              const n = {};
              return (
                e.forEach((e, a) => {
                  const s = g[a];
                  s &&
                    (Ll(s, b)
                      ? t.push({ rIndex: r, checked: We(e) })
                      : Ll(s, E)
                      ? (!l && (l = s), We(e) && (o = a))
                      : s.field && Pt(n, s.field, e));
                }),
                n
              );
            });
          if ((n && (r = n(Et({}, m, { insertRows: r }))), r && r.length))
            return Promise.resolve(A).then(() =>
              I.insertAt(r, -1).then(({ rows: e }) => {
                const { afterFullData: r } = tl;
                return (
                  (C = Kt(r)),
                  (m.insertRows = e),
                  l && (e[o] ? I.setRadioRow(e[o]) : I.clearRadioRow()),
                  t.forEach((t) => {
                    I.setCheckboxRow(e[t.rIndex], t.checked);
                  }),
                  yl[V]([{ type: a, startColumn: x, endColumn: R, startRow: v, endRow: C }], { column: x, row: v }),
                  m
                );
              }),
            );
        }
        return Promise.resolve(m);
      }
      function Oe(e, t, l) {
        const o = nl.value,
          { isFillPaste: r } = o,
          n = l.map((e) => e.slice(0)),
          a = e.length,
          s = t.length,
          i = l.length,
          c = l[0].length;
        if (r || (0 == a % i && 0 == s % c)) {
          if (a > i) {
            const e = l.map((e) => e.slice(0));
            for (let t = P(a / i) - 2; 0 <= t; ) n.push(...e.map((e) => e.slice(0))), t--;
            r && (n.length = K(n.length, a));
          }
          s > c &&
            n.forEach((e) => {
              const t = e.slice(0);
              for (let l = P(s / c) - 2; 0 <= l; ) e.push(...t.slice(0)), l--;
              r && (e.length = K(e.length, s));
            });
        }
        return n;
      }
      function Ne(e, l) {
        const { filterStore: o } = el,
          r = nl.value,
          {
            cutMethod: n,
            beforeCutMethod: s,
            afterCutMethod: i,
            pasteMethod: c,
            beforePasteMethod: d,
            afterPasteMethod: u,
          } = r,
          f = yl[B](),
          g = yl[$]();
        let m = !1,
          p = [];
        if (!o.visible) {
          if ((e && Kl(e), f.length)) {
            const e = Yt(f),
              { rows: o, cols: r } = e,
              { xegrid: w } = I,
              x = Yt(r),
              A = Yt(o),
              R = [],
              S = f.map(({ rows: e, cols: t }) => ({ rows: e, cols: t })),
              T = [];
            let D = !1;
            if (Il && Il.cut) {
              D = !0;
              const e = Il.cellAreas[0],
                { cols: t, rows: l } = e;
              if (
                (T.push({ rows: t, cols: l }),
                !s || !1 !== s({ activeArea: g, cutAreas: T, currentAreas: S, $table: I, $grid: w }))
              ) {
                let e;
                const o = null;
                Vt(l, (l) => {
                  Vt(t, (t) => {
                    if (n) n({ row: l, column: t, cellValue: o, $table: I, $grid: w });
                    else {
                      const { field: r } = t;
                      Ll(t, b)
                        ? I.setCheckboxRow(l, !1)
                        : Ll(t, E)
                        ? I.isCheckedByRadioRow(l) && (e = l)
                        : r && Pt(l, r, o);
                    }
                  });
                }),
                  e && I.clearRadioRow(),
                  yl[k](),
                  i && i({ cutAreas: T, currentAreas: S, $table: I, $grid: w });
              }
            }
            const { text: F } = l,
              $ = {},
              B = Date.now();
            let M,
              W = null;
            F &&
              Vt(F.replace(/(^\r\n)|(\r\n$)/, '').split(t), (e) => {
                const t = [];
                Vt(e.split(Jl), (e) => {
                  let l = e.trim();
                  /\n/.test(l) &&
                    (l = $e(
                      l
                        .replace(/("")|(\n)/g, (e, t) => {
                          const l = Be(B);
                          return ($[l] = t ? '"' : '\n'), l;
                        })
                        .replace(/"(.*?)"/g, (e, t) => Me(t, $)),
                      $,
                    )),
                    t.push(l);
                }),
                  R.push(t);
              });
            const L = (e, t, l) => {
              c
                ? c({ isCut: D, row: e, column: t, cellValue: l, $table: I, $grid: w })
                : Ll(t, b)
                ? I.setCheckboxRow(e, We(l))
                : Ll(t, E)
                ? (!W && (W = t), We(l) && (M = e))
                : t.field && Pt(e, t.field, l);
            };
            if (1 === R.length && 1 === R[0].length) {
              p = S;
              const e = R;
              (d &&
                !1 ===
                  d({
                    isCut: D,
                    activeArea: g,
                    cutAreas: T,
                    currentAreas: S,
                    targetAreas: p,
                    cellValues: e,
                    pasteCells: e,
                    $table: I,
                    $grid: w,
                  })) ||
                ke({
                  isCut: D,
                  cutAreas: T,
                  currentAreas: S,
                  targetAreas: p,
                  cellValues: e,
                  pasteCells: e,
                  $table: I,
                  $grid: w,
                }).then((t) => {
                  const l = e[0][0];
                  (m = !0),
                    Vt(f, (e) => {
                      const { rows: t, cols: o } = e;
                      Vt(t, (e) => {
                        Vt(o, (t) => {
                          L(e, t, l);
                        });
                      });
                    }),
                    u && u(t);
                });
            } else if (1 < f.length) {
              if (
                !f.every((e) => {
                  const { rows: t, cols: l } = e;
                  return R.length === t.length && R[0].length === l.length;
                })
              )
                return void (zt && zt[y]({ message: Jt('vxe.pro.area.pasteMultiErr'), status: C, id: v }));
              p = S;
              const e = R;
              (d &&
                !1 ===
                  d({
                    isCut: D,
                    activeArea: g,
                    cutAreas: T,
                    currentAreas: S,
                    targetAreas: p,
                    cellValues: e,
                    pasteCells: e,
                    $table: I,
                    $grid: w,
                  })) ||
                ke({
                  isCut: D,
                  cutAreas: T,
                  currentAreas: S,
                  targetAreas: p,
                  cellValues: e,
                  pasteCells: e,
                  $table: I,
                  $grid: w,
                }).then((t) => {
                  (m = !0),
                    Vt(f, (t) => {
                      const { rows: l, cols: o } = t;
                      Vt(l, (t, l) => {
                        Vt(o, (o, r) => {
                          const n = e[l][r];
                          L(t, o, n);
                        });
                      });
                    }),
                    u && u(t);
                });
            } else if (1 === f.length) {
              const { afterFullData: e, visibleColumn: t } = tl;
              let l = A,
                n = x;
              const s = Ul(A),
                i = Pl(x);
              if (-1 < i && -1 < s) {
                const c = [],
                  f = [],
                  b = [],
                  E = Oe(o, r, R),
                  F = E.length,
                  $ = E[0].length;
                for (let o = 0; o < F; o++) {
                  const r = E[o],
                    d = s + o,
                    u = e[d];
                  if (u) {
                    const g = [];
                    for (let c = 0; c < $; c++) {
                      const u = r[c],
                        m = i + c,
                        p = t[m];
                      if (p) {
                        const r = ae(d, m);
                        if (r) {
                          const { row: o, col: c, rowspan: d, colspan: u } = r;
                          if (s + F < o + d || i + $ < c + u)
                            return (
                              (l = e[o + d - 1]),
                              (n = t[c + u - 1]),
                              yl[V]([{ type: a, startColumn: x, endColumn: n, startRow: A, endRow: l }], {
                                column: x,
                                row: A,
                              }),
                              void (zt && zt[y]({ message: Jt('vxe.pro.area.mergeErr'), status: C, id: v }))
                            );
                        }
                        o || f.push(p), g.push(u);
                      }
                    }
                    c.push(u), b.push(g);
                  }
                }
                (p = [{ rows: c, cols: f }]),
                  (d &&
                    !1 ===
                      d({
                        isCut: D,
                        activeArea: g,
                        cutAreas: T,
                        currentAreas: S,
                        targetAreas: p,
                        cellValues: b,
                        pasteCells: E,
                        $table: I,
                        $grid: w,
                      })) ||
                    ke({
                      isCut: D,
                      cutAreas: T,
                      currentAreas: S,
                      targetAreas: p,
                      cellValues: b,
                      pasteCells: E,
                      $table: I,
                      $grid: w,
                    }).then((e) => {
                      const { visibleColumn: t, afterFullData: o } = tl,
                        { insertColumns: r, insertRows: c } = e;
                      (m = !0),
                        Vt(b, (e, r) => {
                          const a = o[s + r];
                          a &&
                            ((l = a),
                            Vt(e, (e, l) => {
                              const o = t[i + l];
                              o && ((n = o), L(a, o, e));
                            }));
                        }),
                        r.length
                          ? ((n = Kt(r)),
                            Vt(E, (e, t) => {
                              const l = o[s + t],
                                n = e.length - r.length;
                              l &&
                                Vt(r, (t, o) => {
                                  const r = e[n + o];
                                  L(l, t, r);
                                });
                            }))
                          : !c.length &&
                            yl[V]([{ type: a, startColumn: x, endColumn: n, startRow: A, endRow: l }], {
                              column: x,
                              row: A,
                            }),
                        u && u(e);
                    });
              }
            } else return void (zt && zt[y]({ message: Jt('vxe.pro.area.multiErr'), status: C, id: v }));
            W && (M ? I.setRadioRow(M) : I.clearRadioRow());
          } else if (1 < f.length)
            return void (zt && zt[y]({ message: Jt('vxe.pro.area.multiErr'), status: C, id: v }));
          e && I[T]('cell-area-paste', { status: m, targetAreas: m ? p : [] }, e);
        }
      }
      function _e(e) {
        const t = Fe(e, !1),
          { text: l, html: o, status: r } = t;
        return r && Ve(t, !1), { text: l, html: o };
      }
      function He(e) {
        const t = Fe(e, !0),
          { text: l, html: o, status: r } = t;
        return r && Ve(t, !0), { text: l, html: o };
      }
      function Ue(e) {
        const { clipboard: t } = Zt;
        return t && (t.html || t.text) && Ne(e, t), nextTick();
      }
      function Pe(e, t) {
        const l = Ul(Yt(e)),
          o = Pl(Yt(t));
        for (let r = 0, n = e.length; r < n; r++) {
          const e = l + r;
          for (let r = 0, a = t.length; r < a; r++) {
            const t = o + r,
              s = ae(e, t);
            if (s) {
              const { row: e, col: t, rowspan: r, colspan: i } = s;
              if (l > e || l + n < e + r || o > t || o + a < t + i) return !1;
            }
          }
        }
        return !0;
      }
      function Ye(e, t, l) {
        const o = Ul(t),
          r = Pl(l);
        if (e.length) {
          if (1 === e.length) {
            const { cols: t, rows: l } = Yt(e);
            if (1 === t.length && 1 === l.length) return !0;
            else {
              const e = Ul(Yt(l)),
                n = Pl(Yt(t)),
                a = ae(o, r);
              if (a) {
                const { row: o, col: r, rowspan: s, colspan: i } = a;
                if (e === o && l.length === s && n === r && t.length === i) return !0;
              }
            }
          }
          return !1;
        }
        return !0;
      }
      function Ke(e, t, l) {
        const { afterFullData: o, visibleColumn: r } = tl;
        let n = o[e];
        const a = r[t];
        if (n) {
          const e = Ul(n),
            t = Pl(a),
            l = ae(e, t);
          if (l) {
            const { row: t } = l;
            e !== t && (n = o[t]);
          }
        } else if (l) return t--, 0 > t && (t = r.length - 1), (e = o.length - 1), Ke(e, t, l);
        return { offsetRow: n, offsetColumn: a };
      }
      function Xe(e, t, l) {
        const { afterFullData: o, visibleColumn: r } = tl;
        let n = o[e];
        const a = r[t];
        if (n) {
          const e = Ul(n),
            t = Pl(a),
            l = ae(e, t);
          if (l) {
            const { row: t, rowspan: r } = l;
            e !== t && (n = o[t + r - 1 + 1]);
          }
        } else if (l) return t++, t > r.length - 1 && (t = 0), (e = 0), Xe(e, t, l);
        return { offsetRow: n, offsetColumn: a };
      }
      function je(e, t, l) {
        const { afterFullData: o, visibleColumn: r } = tl,
          n = o[e];
        let a = r[t];
        if (a) {
          const e = Ul(n),
            t = Pl(a),
            l = ae(e, t);
          if (l) {
            const { col: e } = l;
            t !== e && (a = r[e]);
          }
        } else if (l) return e--, 0 > e && (e = o.length - 1), (t = r.length - 1), je(e, t, l);
        return { offsetRow: n, offsetColumn: a };
      }
      function qe(e, t, l) {
        const { afterFullData: o, visibleColumn: r } = tl,
          n = o[e];
        let a = r[t];
        if (a) {
          const e = Ul(n),
            t = Pl(a),
            l = ae(e, t);
          if (l) {
            const { col: e, colspan: o } = l;
            t !== e && (a = r[t + o - 1 + 1]);
          }
        } else if (l) return e++, e > o.length - 1 && (e = 0), (t = 0), qe(e, t, l);
        return { offsetRow: n, offsetColumn: a };
      }
      function Ge(e, t, l, o) {
        const { afterFullData: r } = tl,
          n = e[t],
          { cols: a, rows: s } = n;
        let i = s[l];
        const c = a[o];
        if (i) {
          const d = Ul(i),
            u = Pl(c),
            f = ae(d, u);
          if (f) {
            const { row: g, col: m } = f,
              p = Nl(s, r[g]);
            return d === g && u === m
              ? ((l = p), (i = s[o]), { offsetArea: n, offsetRow: i, offsetColumn: c })
              : (u === m
                  ? ((l = p), (i = s[l]))
                  : ((l = p - 1), 0 > l && (o--, 0 > o && (o = a.length - 1), (l = s.length - 1))),
                Ge(e, t, l, o));
          }
          return { offsetArea: n, offsetRow: i, offsetColumn: c };
        }
        return (
          o--,
          0 > o
            ? (t--, 0 > t && (t = e.length - 1), (l = e[t].rows.length - 1), (o = e[t].cols.length - 1))
            : (l = s.length - 1),
          Ge(e, t, l, o)
        );
      }
      function ze(e, t, l, o) {
        const { afterFullData: r } = tl,
          n = e[t],
          { cols: a, rows: s } = n;
        let i = s[l];
        const c = a[o];
        if (i) {
          const d = Ul(i),
            u = Pl(c),
            f = ae(d, u);
          if (f) {
            const { row: g, col: m, rowspan: p } = f,
              w = Nl(s, r[g]);
            return d === g && u === m
              ? ((l = w), (i = s[l]), { offsetArea: n, offsetRow: i, offsetColumn: c })
              : (u === m
                  ? ((l = w + p - 1 + 1), (i = s[l]))
                  : ((l = w + p - 1 + 1), l > s.length + 1 && (o++, l > a.length - 1 && (o = 0), (l = 0))),
                ze(e, t, l, o));
          }
          return { offsetArea: n, offsetRow: i, offsetColumn: c };
        }
        return (
          l++,
          o++,
          l > s.length - 1 && (l = 0),
          o > a.length - 1 && (t++, t > e.length - 1 && (t = 0), (o = 0)),
          ze(e, t, l, o)
        );
      }
      function Je(e, t, l, o, r, n, s) {
        Kl(e);
        const i = Wl(e, w),
          { row: c, column: d } = t,
          u = yl[B](),
          f = !i || Ye(u, c, d);
        if (f) {
          let t = Ul(c),
            u = Pl(d),
            f = c,
            g = d;
          const m = ae(t, u);
          if (r) {
            if (m) {
              const { row: e } = m;
              t = e;
            }
            const { offsetRow: e, offsetColumn: l } = Ke(t - 1, u, i);
            (f = e), (g = l);
          } else if (s) {
            if (m) {
              const { row: e, rowspan: l } = m;
              t = e + l - 1;
            }
            const { offsetRow: e, offsetColumn: l } = Xe(t + 1, u, i);
            (f = e), (g = l);
          } else if (o) {
            if (m) {
              const { col: e } = m;
              u = e;
            }
            const { offsetRow: e, offsetColumn: l } = je(t, u - 1);
            (f = e), (g = l);
          } else if (n) {
            if (m) {
              const { col: e, colspan: t } = m;
              u = e + t - 1;
            }
            const { offsetRow: e, offsetColumn: l } = qe(t, u + 1);
            (f = e), (g = l);
          }
          if (f && g) {
            const t = { row: c, column: d, isTab: !1, isEnter: i, isLeft: o, isUp: r, isRight: n, isDown: s };
            if ((I[T]('active-cell-change-start', { ...t, activeArea: l }, e), e.cancelBubble)) return;
            I[W](f, g),
              yl[V]([{ type: a, startColumn: g, endColumn: g, startRow: f, endRow: f }], { column: g, row: f }).then(
                () => {
                  I[T]('active-cell-change-end', { ...t, beforeActiveArea: l, activeArea: yl[$]() }, e);
                },
              );
          }
        } else {
          const t = yl[$]();
          if (t) {
            const { area: l, row: a, column: c } = t,
              d = Lt(u, (e) => e === l);
            let f = u[d],
              g = a,
              m = c;
            if (f) {
              const { cols: e, rows: t } = f,
                l = Nl(t, a),
                o = kl(e, c),
                { offsetArea: n, offsetRow: s, offsetColumn: i } = r ? Ge(u, d, l - 1, o) : ze(u, d, l + 1, o);
              (f = n), (g = s), (m = i);
            }
            if (g && m) {
              const l = { row: a, column: c, isTab: !1, isEnter: i, isLeft: o, isUp: r, isRight: n, isDown: s };
              if ((I[T]('active-cell-change-start', { ...l, activeArea: t }, e), e.cancelBubble)) return;
              I[W](g, m)
                .then(() => {
                  yl[M]({ area: f, column: m, row: g });
                })
                .then(() => {
                  I[T]('active-cell-change-end', { ...l, beforeActiveArea: t, activeArea: yl[$]() }, e);
                });
            }
          }
        }
      }
      function Ze(e, t, l, o) {
        if ((Kl(e), 1 >= l.length)) {
          const { row: e, column: l } = t,
            { row: r, column: n } = o,
            s = Ul(e),
            i = Pl(l),
            c = Ul(r),
            d = Pl(n),
            u = s > c ? r : e,
            f = s > c ? e : r,
            g = i > d ? n : l,
            m = i > d ? l : n;
          yl[V]([{ type: a, startRow: u, endRow: f, startColumn: g, endColumn: m }], { column: l, row: e });
        } else zt && zt[y]({ message: Jt('vxe.pro.area.multiErr'), status: C, id: v });
      }
      function Qe(e, t, l, o, r, n) {
        Kl(e);
        const { afterFullData: s, visibleColumn: i } = tl,
          { area: c, row: d, column: u } = t,
          { rows: f, cols: g } = c;
        let m = Yt(f),
          p = Kt(f),
          w = Yt(g),
          v = Kt(g);
        const C = Ul(d),
          x = Pl(u);
        let A = Ul(m),
          R = Pl(w),
          b = Ul(p),
          E = Pl(v),
          S = f,
          y = g;
        const D = ae(C, x);
        if (o || n) {
          if (o) {
            if (
              (Vt(g, (e) => {
                const t = Pl(e),
                  l = ae(b, t);
                if (l) {
                  const { row: e } = l;
                  b = K(b, e);
                }
              }),
              b > (D ? C + D.rowspan - 1 : C))
            )
              (b -= 1), (p = s[b]);
            else {
              if (0 >= A) return;
              (A -= 1), (m = s[A]);
            }
          } else if (
            (Vt(g, (e) => {
              const t = Pl(e),
                l = ae(A, t);
              if (l) {
                const { row: e, rowspan: t } = l;
                A = Y(A, e + t - 1);
              }
            }),
            A < (D ? C + D.rowspan - 1 : C))
          )
            (A += 1), (m = s[A]);
          else {
            if (b >= s.length - 1) return;
            (b += 1), (p = s[b]);
          }
          const { rows: e, cols: t } = fe(St(s, A, b + 1), y);
          (S = e), (y = t);
        } else {
          if (l) {
            if (
              (Vt(f, (e) => {
                const t = Ul(e),
                  l = ae(t, E);
                if (l) {
                  const { col: e } = l;
                  E = K(E, e);
                }
              }),
              E > (D ? x + D.colspan - 1 : x))
            )
              (E -= 1), (v = i[E]);
            else {
              if (0 >= R) return;
              (R -= 1), (w = i[R]);
            }
          } else if (
            (Vt(f, (e) => {
              const t = Ul(e),
                l = ae(t, R);
              if (l) {
                const { col: e, colspan: t } = l;
                R = Y(R, e + t - 1);
              }
            }),
            R < (D ? x + D.colspan - 1 : x))
          )
            (R += 1), (w = i[R]);
          else {
            if (E >= i.length - 1) return;
            (E += 1), (v = i[E]);
          }
          const { rows: e, cols: t } = fe(S, St(i, R, E + 1));
          (S = e), (y = t);
        }
        (m = Yt(S)),
          (p = Kt(S)),
          (w = Yt(y)),
          (v = Kt(y)),
          I[T]('cell-area-arrows-start', { rows: f, cols: g, isLeft: l, isUp: o, isRight: r, isDown: n }, e),
          o || n ? I[W](Yt(f) === m ? p : m) : I[L](Yt(g) === w ? v : w),
          yl[V]([{ type: a, startRow: m, endRow: p, startColumn: w, endColumn: v }], { column: u, row: d }),
          I[T](
            'cell-area-arrows-end',
            { rows: f, cols: g, isLeft: l, isUp: o, isRight: r, isDown: n, targetRows: S, targetCols: y },
            e,
          );
      }
      function et(e, t, l, o) {
        const { visibleColumn: r } = tl,
          n = e[t],
          { cols: a, rows: s } = n,
          i = s[l];
        let c = a[o];
        if (c) {
          const d = Ul(i),
            u = Pl(c),
            f = ae(d, u);
          if (f) {
            const { row: g, col: m } = f,
              p = kl(a, r[m]);
            return d === g && u === m
              ? ((o = p), (c = a[o]), { offsetArea: n, offsetRow: i, offsetColumn: c })
              : (d === g
                  ? ((o = p), (c = a[o]))
                  : ((o = p - 1), 0 > o && (l--, 0 > l && (l = s.length - 1), (o = a.length - 1))),
                et(e, t, l, o));
          }
          return { offsetArea: n, offsetRow: i, offsetColumn: c };
        }
        return (
          l--,
          0 > l
            ? (t--, 0 > t && (t = e.length - 1), (l = e[t].rows.length - 1), (o = e[t].cols.length - 1))
            : (o = a.length - 1),
          et(e, t, l, o)
        );
      }
      function tt(e, t, l, o) {
        const { visibleColumn: r } = tl,
          n = e[t],
          { cols: a, rows: s } = n,
          i = s[l];
        let c = a[o];
        if (c) {
          const d = Ul(i),
            u = Pl(c),
            f = ae(d, u);
          if (f) {
            const { row: g, col: m, colspan: p } = f,
              w = kl(a, r[m]);
            return d === g && u === m
              ? ((o = w), (c = a[o]), { offsetArea: n, offsetRow: i, offsetColumn: c })
              : (d === g
                  ? ((o = w + p - 1 + 1), (c = a[o]))
                  : ((o = w + p - 1 + 1),
                    o > a.length - 1 &&
                      (l++, l > s.length - 1 && (t++, t > e.length - 1 && (t = 0), (l = 0)), (o = 0))),
                tt(e, t, l, o));
          }
          return { offsetArea: n, offsetRow: i, offsetColumn: c };
        }
        return l++, l > s.length - 1 ? (t++, t > e.length - 1 && (t = 0), (l = 0), (o = 0)) : (o = 0), tt(e, t, l, o);
      }
      function lt(e, t, l, o, r, n) {
        const { column: s, row: i } = t,
          c = yl[B](),
          d = Ye(c, i, s);
        if (d) {
          const t = Ul(i);
          let c = Pl(s),
            d = i,
            u = s;
          const f = ae(t, c);
          if (f) {
            const { col: e, colspan: t } = f;
            c = o ? e : c + t - 1;
          }
          const { offsetRow: g, offsetColumn: m } = o ? je(t, c - 1, !0) : qe(t, c + 1, !0);
          if (((d = g), (u = m), d && u)) {
            const t = { row: i, column: s, isTab: r, isEnter: n, isLeft: o, isUp: !1, isRight: !1, isDown: !1 };
            if ((I[T]('active-cell-change-start', { ...t, activeArea: l }, e), e.cancelBubble)) return;
            I[W](d, u),
              yl[V]([{ type: a, startColumn: u, endColumn: u, startRow: d, endRow: d }], { column: u, row: d }).then(
                () => {
                  I[T]('active-cell-change-end', { ...t, beforeActiveArea: l, activeArea: yl[$]() }, e);
                },
              );
          }
        } else if (l) {
          const { area: t, row: a, column: s } = l,
            i = Lt(c, (e) => e === t);
          let d = c[i],
            u = a,
            f = s;
          if (d) {
            const { cols: e, rows: t } = d,
              l = Nl(t, a),
              r = kl(e, s),
              { offsetArea: n, offsetRow: g, offsetColumn: m } = o ? et(c, i, l, r - 1) : tt(c, i, l, r + 1);
            (d = n), (u = g), (f = m);
          }
          if (u && f) {
            const t = { row: a, column: s, isTab: r, isEnter: n, isLeft: o, isUp: !1, isRight: !1, isDown: !1 };
            if ((I[T]('active-cell-change-start', { ...t, activeArea: l }, e), e.cancelBubble)) return;
            I[W](u, f).then(() => {
              yl[M]({ area: d, column: f, row: u }).then(() => {
                I[T]('active-cell-change-end', { ...t, beforeActiveArea: l, activeArea: yl[$]() }, e);
              });
            });
          }
        }
      }
      function ot(e, t, l, o, r, n, a, s) {
        const { clientX: i, clientY: c } = e,
          { scrollbarWidth: d } = el,
          u = hl.value,
          f = gl.value,
          g = i - l,
          m = c - o,
          p = a.scrollLeft,
          w = s.scrollTop;
        let v = g + (p - r);
        const C = m + (w - n);
        let x,
          A,
          R = 0;
        u && ((R = u.offsetWidth), (x = ql(u))), f && (A = ql(f));
        const { scrollWidth: b, offsetWidth: E } = a,
          S = b - E - p;
        return (
          x && A
            ? 'left' === t
              ? i > A.left
                ? (v = g + p + d + S)
                : i < x.left + R && (v = g)
              : 'right' === t
              ? i < x.left + R
                ? (v = g - d - S - p)
                : i < A.left && (v = g - d - S)
              : i < x.left + R
              ? (v = g - d - (r - p) - p)
              : i > A.left && (v = g + (p - r) + d + S)
            : x
            ? 'left' === t
              ? i < x.left + R && (v = g)
              : i < x.left + R && (v = g - d - (r - p) - p)
            : A && ('right' === t ? i < A.left && (v = g - d - S) : i > A.left && (v = g + (p - r) + d + S)),
          { moveX: g, moveY: m, offsetLeft: v, offsetTop: C }
        );
      }
      function rt(e) {
        const t = Cl.value;
        if (((t.showREErr = !1), (t.findCellRE = null), t.isRE))
          try {
            t.findCellRE = new RegExp(e, t.isSensitive ? '' : 'i');
          } catch (l) {
            return (t.showREErr = !0), zt && zt[y]({ message: Jt('vxe.pro.fnr.reError'), status: C, id: v }), !1;
          }
        return !0;
      }
      function nt(e, t, l) {
        if (t.field) {
          const o = Cl.value,
            r = rl.value,
            { isWhole: n, isRE: a, isSensitive: s, findCellRE: i } = o,
            { findMethod: c } = r;
          let d = Ot(Ut(e, t.field));
          return c
            ? c({ cellValue: d, isWhole: n, isRE: a, isSensitive: s, findValue: l, findRE: i })
            : l
            ? a
              ? i && i.test(d)
              : (s || ((d = Bl(d)), (l = Bl(l))), n ? d === l : -1 < yt(d, l))
            : !d;
        }
        return !1;
      }
      function at(e, t, l, o, r, n, a, s, i) {
        const { afterFullData: c, visibleColumn: d } = tl,
          u = [];
        for (let f = t, g = e.length; f < g; f++) {
          const g = e[f],
            { rows: m, cols: p } = g,
            w = Ul(Yt(m)),
            v = Pl(Yt(p));
          for (let e = f === t ? o : 0, C = m.length; e < C; e++) {
            const m = w + e;
            for (let w = f === t && e === o ? n : 0, C = p.length; w < C; w++) {
              const t = v + w,
                o = ae(m, t);
              if (o) {
                const { row: e, col: l } = o;
                if (m !== e || t !== l) continue;
              }
              const n = c[m],
                p = d[t];
              if (
                nt(n, p, s) &&
                (u.push({ _rowIndex: m, _columnIndex: t, offsetArea: g, offsetRow: n, offsetColumn: p }), !i)
              )
                return u;
              if (f >= l && e >= r && w >= a) return u;
            }
          }
        }
        return u;
      }
      function st(e, t, l, o, r, n) {
        const { afterFullData: a, visibleColumn: s } = tl,
          i = Ul(e),
          c = Pl(t) + 1,
          d = Ul(l),
          u = Pl(o) + 1,
          f = [];
        for (let g = 0, m = a.length; g < m; g++) {
          const e = i + g;
          for (let t = 0 == g ? c : 0, l = s.length; t < l; t++) {
            const l = ae(e, t);
            if (l) {
              const { row: o, col: r } = l;
              if (e !== o || t !== r) continue;
            }
            const o = a[e],
              i = s[t];
            if (nt(o, i, r) && (f.push({ _rowIndex: e, _columnIndex: t, offsetRow: o, offsetColumn: i }), !n)) return f;
            if (g >= d && t >= u) return f;
          }
        }
        return f;
      }
      function it() {
        Vt(xl.value, (e) => {
          e.isActived = !1;
        });
      }
      function ct() {
        nextTick(() => {
          if (Zl) {
            const { refElem: e } = Zl.getRefMaps(),
              t = e.value;
            if (t) {
              const e = jl(t, '.vxe-table--fnr-form-input .vxe-input--inner');
              e && (I.blur(), e.focus());
            }
          }
        });
      }
      function dt(e) {
        const t = Cl.value,
          { afterFullData: l, visibleColumn: o } = tl,
          r = yl[$](),
          n = yl[B]();
        let s = Yt(l),
          i = Yt(o),
          c = Kt(l),
          d = Kt(o);
        const u = Ot(t.findValue);
        let f = [],
          g = !0;
        if (((t.showREErr = !1), !rt(u))) return f;
        if (r) {
          const { row: t, column: l } = r;
          (g = Ye(n, t, l)), !e && g && ((s = t), (i = l));
        }
        if (g) {
          if (
            ((f = st(s, i, c, d, u, e)),
            !e && (f.length || ((c = s), (d = i), (s = Yt(l)), (i = Yt(o)), (f = st(s, i, c, d, u, e))), f.length))
          ) {
            const { offsetRow: e, offsetColumn: t } = f[0];
            I[W](e, t), yl[V]([{ type: a, startRow: e, endRow: e, startColumn: t, endColumn: t }]);
          }
        } else if (r) {
          const { area: t, row: l, column: o } = r;
          let a = e ? 0 : Lt(n, (e) => e === t);
          const s = n[a];
          if (s) {
            const { cols: t, rows: r } = s;
            let i = e ? 0 : Nl(r, l),
              c = e ? 0 : kl(t, o) + 1,
              d = n.length - 1;
            const g = n[d];
            let m = g.rows.length - 1,
              p = g.cols.length - 1;
            if (
              ((f = at(n, a, d, i, m, c, p, u, e)),
              !e &&
                (f.length ||
                  ((d = a), (m = i), (p = c), (a = 0), (i = 0), (c = 0), (f = at(n, a, d, i, m, c, p, u, e))),
                f.length))
            ) {
              const { offsetArea: e, offsetRow: t, offsetColumn: l } = f[0];
              I[W](t, l).then(() => {
                yl[M]({ area: e, column: l, row: t });
              });
            }
          }
        }
        return f;
      }
      function ut() {
        const e = Cl.value;
        (e.visible = !1), (e.showCount = !1), (xl.value = []), (Zl = null);
      }
      function ft(e) {
        const t = ll.value,
          l = Cl.value,
          r = rl.value,
          n = yl[$](),
          a = _t(bl, (e) => ('find' === e.value && !!r.isFind) || ('replace' === e.value && !!r.isReplace)),
          s = -1 < yt(a, e) ? e : a[0];
        o &&
          s &&
          ((l.visible = !0),
          (l.activeTab = s.value),
          (l.findValue = n ? Ut(n.row, n.column.field) : ''),
          zt.open({
            title: Jt('vxe.pro.fnr.title'),
            className: 'vxe-table--ignore-areas-clear vxe-table--fnr',
            size: t,
            width: 540,
            minWidth: 540,
            height: 370,
            minHeight: 370,
            resize: !0,
            showZoom: !0,
            lockView: !1,
            mask: !1,
            escClosable: !0,
            onHide() {
              ut(), I.focus();
            },
            onShow(e) {
              (Zl = e.$modal), ct();
            },
            slots: {
              default(e) {
                const t = Cl.value,
                  { $modal: l } = e,
                  { activeTab: o, isRE: r, showREErr: n } = t,
                  s = [],
                  i = 'vxe-table--fnr-';
                return (
                  'replace' === o &&
                    s.push(
                      h(resolveComponent('vxe-button'), { content: Jt('vxe.pro.fnr.btns.replaceAll'), onClick: oo }),
                      h(resolveComponent('vxe-button'), { content: Jt('vxe.pro.fnr.btns.replace'), onClick: to }),
                    ),
                  s.push(
                    h(resolveComponent('vxe-button'), { content: Jt('vxe.pro.fnr.btns.findAll'), onClick: ao }),
                    h(resolveComponent('vxe-button'), {
                      key: 'findNext',
                      status: 'primary',
                      content: Jt('vxe.pro.fnr.btns.findNext'),
                      onClick: ro,
                    }),
                    h(resolveComponent('vxe-button'), {
                      content: Jt('vxe.pro.fnr.btns.cancel'),
                      onClick() {
                        l.close();
                      },
                    }),
                  ),
                  [
                    h(
                      'div',
                      { class: i + 'tabs' },
                      a.map((e, t) =>
                        h(
                          'span',
                          {
                            key: t,
                            class: { 'is--active': o === e.value },
                            onClick(t) {
                              Ql(t, e);
                            },
                          },
                          Jt(e.label),
                        ),
                      ),
                    ),
                    h('div', { class: i + 'body' }, [
                      h('table', { class: i + 'form', cellspacing: 0, cellpadding: 0, border: 0 }, [
                        h('tbody', [
                          h('tr', { class: 'is--visible' }, [
                            h('td', { class: i + 'form-title' }, Jt('vxe.pro.fnr.findTitle')),
                            h('td', { class: i + 'form-content' }, [
                              h(resolveComponent('vxe-input'), {
                                class: i + 'form-input',
                                modelValue: t.findValue,
                                clearable: !0,
                                onKeydown: no,
                                'onUpdate:modelValue'(e) {
                                  t.findValue = e;
                                },
                              }),
                            ]),
                            h('td', { class: i + 'form-filter', rowspan: 2 }, [
                              h(resolveComponent('vxe-checkbox'), {
                                modelValue: r,
                                content: Jt('vxe.pro.fnr.filter.re'),
                                'onUpdate:modelValue'(e) {
                                  t.isRE = e;
                                },
                              }),
                              h(resolveComponent('vxe-checkbox'), {
                                modelValue: !r && t.isWhole,
                                disabled: r,
                                content: Jt('vxe.pro.fnr.filter.whole'),
                                'onUpdate:modelValue'(e) {
                                  t.isRE || (t.isWhole = e);
                                },
                              }),
                              h(resolveComponent('vxe-checkbox'), {
                                modelValue: t.isSensitive,
                                content: Jt('vxe.pro.fnr.filter.sensitive'),
                                'onUpdate:modelValue'(e) {
                                  t.isSensitive = e;
                                },
                              }),
                            ]),
                          ]),
                          h('tr', { class: { 'is--visible': 'replace' === t.activeTab } }, [
                            h('td', { class: i + 'form-title' }, Jt('vxe.pro.fnr.replaceTitle')),
                            h('td', { class: i + 'form-content' }, [
                              h(resolveComponent('vxe-input'), {
                                class: i + 'form-input',
                                modelValue: t.replaceValue,
                                clearable: !0,
                                'onUpdate:modelValue'(e) {
                                  t.replaceValue = e;
                                },
                                onKeydown: lo,
                              }),
                            ]),
                          ]),
                        ]),
                      ]),
                    ]),
                    h('div', { class: i + 'footer' }, s),
                    h('div', { class: i + 'search' }, [
                      h('div', { class: i + 'search-header' }, [
                        h('div', Jt('vxe.pro.fnr.header.seq')),
                        h('div', Jt('vxe.pro.fnr.header.cell')),
                        h('div', Jt('vxe.pro.fnr.header.value')),
                      ]),
                      h('div', { class: i + 'search-body' }, [
                        h(
                          resolveComponent('vxe-list'),
                          {
                            class: i + 'search-list',
                            data: xl.value,
                            autoResize: !0,
                            scrollY: { gt: 10, sItem: i + 'find-item' },
                          },
                          {
                            default(e) {
                              const { items: t } = e;
                              return t.map((e) =>
                                h(
                                  'div',
                                  {
                                    key: e.seq,
                                    class: [i + 'find-item', { 'is--active': e.isActived }],
                                    onClick(t) {
                                      eo(t, e);
                                    },
                                  },
                                  [
                                    h('div', e.seq),
                                    h('div', 'Row:' + (e.row + 1) + ', Col:' + (e.col + 1)),
                                    h('div', e.value),
                                  ],
                                ),
                              );
                            },
                          },
                        ),
                      ]),
                      h(
                        'div',
                        { class: [i + 'search-footer', { 'is--error': n, 'is--visible': n || t.showCount }] },
                        n ? Jt('vxe.pro.fnr.reError') : Jt('vxe.pro.fnr.recordCount', [t.findCount]),
                      ),
                    ]),
                  ]
                );
              },
            },
          }));
      }
      function ht(e) {
        const { mouseConfig: t } = Qt,
          l = il.value,
          o = Cl.value;
        return (
          t && l.area && (o.visible ? e.value !== o.activeTab && ((o.activeTab = e.value), ct()) : ft(e)), nextTick()
        );
      }
      function gt(e) {
        const { keyboardConfig: t, editConfig: l, highlightCurrentRow: o } = Qt,
          { editStore: r, filterStore: n, ctxMenuStore: a } = el,
          { xegrid: s } = I,
          i = al.value,
          c = ol.value,
          d = rl.value,
          u = dl.value,
          g = ul.value,
          { actived: m } = r,
          { keyCode: p } = e,
          w = Wl(e, f.SPACEBAR),
          x = Wl(e, f.ESCAPE),
          A = Wl(e, f.ENTER),
          R = Wl(e, f.ARROW_LEFT),
          S = Wl(e, f.ARROW_UP),
          T = Wl(e, f.ARROW_RIGHT),
          D = Wl(e, f.ARROW_DOWN),
          V = Wl(e, f.TAB),
          F = Wl(e, f.BACKSPACE),
          M = Wl(e, f.DELETE),
          W = Wl(e, f.A),
          L = Wl(e, f.X),
          _ = Wl(e, f.C),
          H = Wl(e, f.V),
          U = Wl(e, f.F),
          P = Wl(e, f.H),
          Y = Wl(e, f.M),
          K = Wl(e, f.F2),
          X = Wl(e, f.CONTEXT_MENU),
          j = R || S || T || D,
          q = e.metaKey,
          G = e.ctrlKey,
          z = e.shiftKey,
          J = yl[$](),
          Z = Ml(l) && m.column && m.row,
          Q = c.beforeEditMethod || c.activeMethod;
        if (w && J && t && i.isChecked) {
          const t = J.column,
            l = { row: J.row, column: t };
          Ll(t, b) ? (Kl(e), I.handleToggleCheckRowEvent(e, l)) : Ll(t, E) && (Kl(e), I.triggerRadioRowEvent(e, l));
        }
        if (x)
          n.visible && (e.stopPropagation(), I.closeFilter()),
            a.visible && (e.stopPropagation(), I.closeMenu()),
            Il ? (e.stopPropagation(), yl[k]()) : ie(e);
        else if (K && Ml(l) && J) {
          if (!Z) {
            const { offsetRow: t, offsetColumn: l } = se(J.row, J.column);
            if (Ml(l.editRender)) {
              const o = { row: t, column: l, cell: I.getCell(t, l) };
              Kl(e), I.handleActived(o, e);
            }
          }
        } else if (X)
          (tl._keyCtx = J && J.row && J.column && u.length),
            clearTimeout(uo),
            (uo = setTimeout(() => {
              tl._keyCtx = !1;
            }, 1e3));
        else if (G && Y && t && i.isMerge && J) Z || (Kl(e), ue(e), yl[k]());
        else if (G && t && i.isFNR && ((U && d.isFind) || (P && d.isReplace))) {
          Kl(e);
          const t = Cl.value,
            l = bl[U ? 0 : 1];
          t.visible ? Ql(e, l) : so(e, l.value), ie(e);
        } else if (A && t && i.isEnter) {
          const { column: t, row: l } = m;
          if (t && l) {
            const { offsetRow: o, offsetColumn: r } = se(l, t);
            Kl(e),
              I[O] ? I[O](e) : I[N](e),
              i.enterToTab
                ? lt(e, { row: o, column: r }, J, z, !1, !0)
                : Je(e, { row: o, column: r }, J, !1, z, !1, !z);
          } else
            J &&
              (Kl(e),
              i.enterToTab
                ? lt(e, { row: J.row, column: J.column }, J, z, !1, !0)
                : Je(e, { row: J.row, column: J.column }, J, !1, z, !1, !z));
        } else if (j && t && i.isArrow) {
          if (!Z)
            if (!J) (S || D) && (g.isCurrent || o) && I.moveCurrentRow(S, D, e);
            else if (z) {
              const t = yl[B]();
              1 >= t.length
                ? Qe(e, J, R, S, T, D)
                : zt && zt[y]({ message: Jt('vxe.pro.area.multiErr'), status: C, id: v });
            } else Je(e, { row: J.row, column: J.column }, J, R, S, T, D);
        } else if (V && t && i.isTab) {
          const { column: t, row: l } = m;
          if (l && t) {
            const { offsetRow: o, offsetColumn: r } = se(l, t);
            Kl(e), I[O] ? I[O](e) : I[N](e), lt(e, { row: o, column: r }, J, z, !0, !1);
          } else J && (Kl(e), lt(e, { row: J.row, column: J.column }, J, z, !0, !1));
        } else if ((M || F) && Ml(l) && t && i.isDel) {
          const { delMethod: t, backMethod: l } = i;
          if (!Z)
            if (F && J) {
              const { column: t, row: o } = J;
              if (o && t) {
                const { offsetRow: r, offsetColumn: n } = se(o, t);
                if (Ml(n.editRender)) {
                  const t = {
                    row: r,
                    rowIndex: I.getRowIndex(r),
                    column: n,
                    columnIndex: I.getColumnIndex(n),
                    cell: I.getCell(r, n),
                    $table: I,
                    $grid: s,
                  };
                  (!Q || Q(t)) &&
                    (l ? l(t) : ((t.cell = I.getCell(r, n)), Pt(r, n.field, null), I.handleActived(t, e)));
                }
              }
            } else if (M) {
              const e = yl[B]();
              Vt(e, (e) => {
                const { rows: l, cols: o } = e;
                Vt(l, (e) => {
                  Vt(o, (l) => {
                    if (Ml(l.editRender)) {
                      const o = I.getRowIndex(e),
                        r = I.getColumnIndex(l),
                        n = {
                          row: e,
                          rowIndex: o,
                          column: l,
                          columnIndex: r,
                          cell: I.getCell(e, l),
                          $table: I,
                          $grid: s,
                        };
                      (!Q || Q(n)) && (t ? t(n) : Pt(e, l.field, null));
                    }
                  });
                });
              });
            }
        } else if (t && G && W) Z || io(e);
        else if (t && i.isClip && G && Gt.msie && (L || _ || H));
        else if (
          t &&
          Ml(l) &&
          i.isEdit &&
          !G &&
          !q &&
          (w ||
            (48 <= p && 57 >= p) ||
            (65 <= p && 90 >= p) ||
            (96 <= p && 111 >= p) ||
            (186 <= p && 192 >= p) ||
            (219 <= p && 222 >= p)) &&
          !Z &&
          J
        ) {
          const { column: t, row: l } = J;
          if (l && t) {
            const { offsetRow: o, offsetColumn: r } = se(l, t),
              { editMethod: n } = i;
            if (Ml(r.editRender)) {
              const t = {
                row: o,
                rowIndex: I.getRowIndex(o),
                column: r,
                columnIndex: I.getColumnIndex(r),
                cell: I.getCell(o, r),
                $table: I,
                $grid: s,
              };
              (!Q || Q(t)) && (n ? n(t) : (Pt(o, r.field, null), I.handleActived(t, e)));
            }
          }
        }
      }
      function mt(e) {
        return e.map((e) =>
          e.map((e) => {
            let t = 0;
            const l = !isNaN(e);
            let o = '{0}';
            return l ? (t = e) : (o = Ot(e).replace(/\d+(?!.*\d)/, (e) => ((t = e), '{0}'))), { v: o, n: kt(t), t: l };
          }),
        );
      }
      function pt(e, t) {
        const { targetValues: l, targetRows: o, extendRows: r, extendCols: n } = e,
          a = mt(l),
          s = a[t ? 0 : a.length - 2],
          i = a[t ? 1 : a.length - 1],
          c = n.map((e, l) => {
            const o = s[l],
              r = i[l];
            return { offset: t ? o.n - r.n : r.n - o.n, num: t ? o.n : r.n };
          }),
          d = r.map((e, l) => {
            const r = l % o.length,
              s = a[t ? a.length - r - 1 : r];
            return n.map((e, t) => {
              const l = s[t],
                o = c[t],
                { num: r, offset: n } = o,
                a = r + n;
              return !l.t && 0 >= a && (o.offset = H(n)), (o.num = a), Nt(l.v, [a]);
            });
          });
        return t && d.reverse(), d;
      }
      function wt(e, t) {
        const { targetValues: l, targetCols: o, extendRows: r, extendCols: n } = e,
          a = mt(l),
          s = a.map((e) => {
            const l = e[t ? 0 : e.length - 2],
              o = e[t ? 1 : e.length - 1];
            return { offset: t ? l.n - o.n : o.n - l.n, num: t ? l.n : o.n };
          });
        return r.map((e, l) => {
          const r = s[l],
            i = a[l],
            c = n.map((e, l) => {
              const n = l % o.length,
                a = i[t ? i.length - n - 1 : n],
                { num: s, offset: c } = r,
                d = s + c;
              return !a.t && 0 >= d && (r.offset = H(c)), (r.num = d), Nt(a.v, [d]);
            });
          return t && c.reverse(), c;
        });
      }
      function vt(e, t, l, o) {
        const r = cl.value,
          { xegrid: n } = I,
          { rows: a, cols: s } = o,
          i = a.length > t.length,
          c = s.length > l.length,
          d = e.shiftKey,
          u = e.ctrlKey;
        let f;
        if (!d && (i || c)) {
          const {
              extendByCopy: e,
              extendByCalc: o,
              extendCalcMethod: d,
              extendSetMethod: g,
              beforeExtendSetMethod: m,
              afterExtendSetMethod: p,
            } = r,
            w = Ul(t[0]),
            v = Ul(a[0]),
            C = Pl(l[0]),
            x = Pl(s[0]);
          let A = !1,
            R = !1,
            b = [];
          if (i) {
            const r = !u && o && 2 <= t.length;
            if (e || r) {
              let e = [];
              (b = t.map((e) => l.map((t) => ye(e, t, 0)))),
                v < w ? ((A = !0), (e = a.slice(0, a.length - t.length))) : (e = a.slice(t.length));
              const o = {
                rows: a,
                cols: s,
                targetValues: b,
                targetRows: t,
                targetCols: l,
                extendRows: e.slice(0),
                extendCols: l,
                direction: A ? 'up' : 'down',
                $table: I,
                $grid: n,
              };
              (m && !1 === m(o)) ||
                ((f = b),
                r && (d ? (f = d(o)) : (f = pt(o, A))),
                e.forEach((t, r) => {
                  const n = A ? e.length % f.length : 0,
                    a = (n + r) % f.length,
                    s = f[a];
                  l.forEach((e, l) => {
                    const r = s[l % s.length];
                    if (g) g(Et({ cellValue: r, row: t, column: e }, o));
                    else {
                      const { field: l } = e;
                      l && Pt(t, l, r);
                    }
                  });
                }),
                p && p(Et({ extendValues: f }, o)));
            }
          } else if (c) {
            const r = !u && o && 2 <= l.length;
            if (e || r) {
              let e = [];
              x < C ? ((R = !0), (e = s.slice(0, s.length - l.length))) : (e = s.slice(l.length)),
                (b = t.map((e) => l.map((t) => ye(e, t, 0))));
              const o = {
                rows: a,
                cols: s,
                targetValues: b,
                targetRows: t,
                targetCols: l,
                extendRows: t,
                extendCols: e.slice(0),
                direction: R ? 'left' : 'right',
                $table: I,
                $grid: n,
              };
              (m && !1 === m(o)) ||
                ((f = b),
                r && (d ? (f = d(o)) : (f = wt(o, R))),
                t.forEach((t, l) => {
                  const r = l % f.length,
                    n = f[r],
                    a = R ? e.length % n.length : 0;
                  e.forEach((e, l) => {
                    const r = (a + l) % n.length,
                      s = n[r];
                    if (g) g(Et({ cellValue: s, row: t, column: e }, o));
                    else {
                      const { field: l } = e;
                      l && Pt(t, l, s);
                    }
                  });
                }),
                p && p(Et({ extendValues: f }, o)));
            }
          }
        }
      }
      function Ct(e, t) {
        const { button: l } = e,
          o = 0 === l;
        if (!o) return;
        const { fixed: r } = t,
          n = yl[B](),
          s = Bt(n, (e) => e.type === a);
        if ((Yl(), s)) {
          const l = document.onmousemove,
            o = document.onmouseup,
            n = fl.value,
            a = e.clientX,
            c = e.clientY,
            d = ml.value,
            u = wl.value,
            f = vl.value,
            g = d.$el,
            m = u ? u.$el : null,
            p = f ? f.$el : null,
            w = m || g,
            A = p || g,
            { rows: R, cols: b } = s,
            E = Yt(b),
            S = Yt(R),
            D = Kt(b),
            V = Kt(R),
            F = s.top,
            $ = s.left,
            B = s.width,
            M = s.height,
            W = ee(E.fixed),
            L = jl(W, '.vxe-table--cell-area'),
            k = L.children[2],
            O = w.scrollTop,
            N = 'left' === r ? 0 : A.scrollLeft,
            _ = Ul(V),
            U = Pl(D),
            P = ae(_, U);
          let Y = 1,
            X = 1,
            j = 0,
            q = 0,
            G = '',
            z = null,
            te = null;
          const le = jl(W, '.vxe-body--row'),
            oe = le.firstChild,
            re = { type: i, cols: [], rows: [], top: 0, left: 0, width: 0, height: 0 },
            ne = (e) => {
              const { offsetTop: t, offsetLeft: l } = ot(e, r, a, c, N, O, A, w),
                o = H(t),
                n = H(l),
                i = A.scrollWidth,
                d = w.scrollHeight;
              let u = M,
                f = B,
                g = F,
                m = $;
              switch (G) {
                case 'top':
                  if (t < -M) {
                    const e = K(F, he(S, E, P, !1, o - M));
                    (g -= e), (u += e);
                  }
                  break;
                case 'bottom':
                  0 < t && (u += K(d - F - M, he(V, D, P, !0, o)));
                  break;
                case 'left':
                  if (l < -B) {
                    const e = K($, ge(S, E, P, !1, n - B));
                    (m -= e), (f += e);
                  }
                  break;
                case 'right':
                  0 < l && (f += K(i - $ - B, ge(V, D, P, !0, n)));
              }
              (re.height = u),
                (re.width = f),
                (re.left = m),
                (re.top = g),
                (re.cols = we(oe, re)),
                (re.rows = ve(le, re)),
                Et(re, Ae(re)),
                I[T](
                  'cell-area-extension-drag',
                  { rows: s.rows, cols: s.cols, targetRows: re.rows, targetCols: re.cols },
                  e,
                );
            },
            se = (e) => {
              Yl(),
                (El = setTimeout(() => {
                  if (El) {
                    const { clientHeight: t, clientWidth: l } = g,
                      { scrollLeft: o, scrollWidth: r } = A,
                      { scrollTop: n, scrollHeight: a } = w;
                    let s = null,
                      i = null;
                    null !== z && (z ? n + t < a && (s = n + Y * x) : n && (s = n - Y * x)),
                      null !== te && (te ? o + l < r && (i = o + X * x) : o && (i = o - X * x)),
                      Rt(i) || Rt(s) ? (I.scrollTo(i, s), se(e), ne(e)) : Yl();
                  }
                }, 50));
            };
          (document.onmousemove = (e) => {
            Xl(e);
            const { clientY: t, clientX: l } = e,
              { clientHeight: o, clientWidth: n } = g,
              { offsetTop: s, offsetLeft: i } = ot(e, r, a, c, N, O, A, w),
              d = ql(g),
              u = d.top,
              f = d.left,
              m = $ + B + i,
              p = F + M + s;
            let v;
            (z = null),
              (te = null),
              (j = t),
              (q = l),
              j < u ? ((v = !0), (z = !1), (Y = u - j)) : j > u + o && ((v = !0), (z = !0), (Y = j - u - o)),
              q < f ? ((v = !0), (te = !1), (X = f - q)) : q > f + n && ((v = !0), (te = !0), (X = q - f - n)),
              m < $
                ? p > F && p < F + M && (G = 'left')
                : m > $ + B
                ? p > F && p < F + M && (G = 'right')
                : p < F
                ? (G = 'top')
                : p > F + M && (G = 'bottom'),
              v ? !El && se(e) : Yl(),
              ne(e);
          }),
            (document.onmouseup = () => {
              (document.onmousemove = l), (document.onmouseup = o), Yl(), Q(n, 'drag--extend-range');
              const t = ve(le, re),
                r = we(oe, re);
              Pe(t, r)
                ? ((s.rows = t), (s.cols = r))
                : zt && zt[y]({ message: Jt('vxe.pro.area.extendErr'), status: C, id: v }),
                Et(s, Ae(s)),
                J(k),
                vt(e, R, b, s),
                (Sl = !1),
                I[T]('cell-area-extension-end', { rows: s.rows, cols: s.cols, targetRows: R, targetCols: b }, e);
            }),
            Z(n, 'drag--extend-range'),
            (Sl = !0),
            I[T]('cell-area-extension-start', Et({ targetRows: R, targetCols: b }, t), e);
        }
      }
      function xt(e, t) {
        const { button: l } = e,
          o = 0 === l,
          r = 2 === l;
        if (!(o || r)) return;
        const n = fl.value,
          { editStore: s } = el,
          i = ol.value,
          { actived: u, selected: f } = s,
          { fixed: g, row: m, column: p, cell: w } = t;
        if (Sl) return void Kl(e);
        if (u.row === m && ('cell' === i.mode ? u.column === p : 'row' === i.mode)) return;
        const v = e.ctrlKey,
          C = e.shiftKey,
          A = w.offsetTop,
          R = w.offsetLeft,
          b = w.offsetWidth,
          E = w.offsetHeight;
        let S = yl[B]();
        const y = yl[$]();
        if ((Yl(), !r && C && y)) return void Ze(e, y, S, t);
        if (
          (u.column && (I[O] ? I[O](e) : I[N](e)),
          f.column && I.clearSelected(),
          !r || !Ht(S, (e) => _l(e.rows, m) && Ol(e.cols, p)))
        ) {
          const l = {
            row: y ? y.row : null,
            column: y ? y.column : null,
            isTab: !1,
            isEnter: !1,
            isLeft: !1,
            isUp: !1,
            isRight: !1,
            isDown: !1,
          };
          if ((I[T]('active-cell-change-start', { ...l, activeArea: y }, e), e.cancelBubble)) return;
          v || ((S = []), yl[F]());
          const o = document.onmousemove,
            s = document.onmouseup,
            i = e.clientX,
            u = e.clientY,
            f = ml.value,
            C = wl.value,
            D = vl.value,
            V = ce(e, w),
            B = f.$el,
            W = C ? C.$el : null,
            L = D ? D.$el : null,
            k = W || B,
            O = L || B,
            N = ee(p.fixed),
            _ = jl(N, '.vxe-table--cell-area'),
            U = _.children,
            P = U[0],
            Y = U[2],
            X = U[3],
            j = w,
            q = j.parentNode,
            G = jl(N, '.vxe-body--row'),
            z = G.firstChild,
            le = k.scrollTop,
            re = 'left' === g ? 0 : O.scrollLeft;
          let ne = null,
            ae = null,
            se = 1,
            ie = 1,
            de = 0,
            ue = 0;
          const he = { type: v ? c : a, cols: [], rows: [], top: 0, left: 0, width: 0, height: 0 },
            ge = {
              type: d,
              area: he,
              column: p,
              row: m,
              top: w.offsetTop,
              left: w.offsetLeft,
              width: w.offsetWidth,
              height: w.offsetHeight,
            };
          if (v) {
            const e = g ? `${g}El` : 'el',
              t = Bt(S, (e) => e.type === a);
            t && ((t.type = c), (t[e] = te(X)), oe(t[e], t)), (he[e] = te(X));
          }
          yl[M](ge), S.push(he);
          const Ce = (e) => {
              const { offsetTop: t, offsetLeft: l } = ot(e, g, i, u, re, le, O, k),
                o = O.scrollWidth,
                r = k.scrollHeight,
                n = 0 <= t,
                a = 0 <= l;
              let s,
                c,
                d = H(t),
                f = H(l);
              n
                ? ((s = me(m, p, q, n, d + V.offsetY)), (d = K(r - A, s.moveHeight)))
                : ((s = me(m, p, q, n, d - V.offsetY)), (d = K(A + E, s.moveHeight))),
                a
                  ? ((c = pe(m, p, w, a, f + V.offsetX)), (f = K(o - R, c.moveWidth)))
                  : ((c = pe(m, p, w, a, f - V.offsetX)), (f = K(R + b, c.moveWidth)));
              const { rows: C, cols: x } = fe(s.rows, c.cols);
              (he.rows = C),
                (he.cols = x),
                J(Y),
                v ? (J(P), Gl(X)) : (J(X), Gl(P)),
                Et(he, Ae(he)),
                I[T]('cell-area-selection-drag', { rows: he.rows, cols: he.cols }, e);
            },
            xe = (e) => {
              Yl(),
                (El = setTimeout(() => {
                  if (El) {
                    const { clientHeight: t, clientWidth: l } = B,
                      { scrollLeft: o, scrollWidth: r } = O,
                      { scrollTop: n, scrollHeight: a } = k;
                    let s = null,
                      i = null;
                    null !== ne && (ne ? n + t < a && (s = n + se * x) : n && (s = n - se * x)),
                      null !== ae && (ae ? o + l < r && (i = o + ie * x) : o && (i = o - ie * x)),
                      Rt(i) || Rt(s) ? (I.scrollTo(i, s), xe(e), Ce(e)) : Yl();
                  }
                }, 50));
            };
          r ||
            (document.onmousemove = (e) => {
              Xl(e);
              const { clientY: t, clientX: l } = e,
                { clientHeight: o, clientWidth: r } = B,
                n = ql(B),
                a = n.top,
                s = n.left;
              let i;
              (ne = null),
                (ae = null),
                (de = t),
                (ue = l),
                de < a ? ((i = !0), (ne = !1), (se = a - de)) : de > a + o && ((i = !0), (ne = !0), (se = de - a - o)),
                ue < s ? ((i = !0), (ae = !1), (ie = s - ue)) : ue > s + r && ((i = !0), (ae = !0), (ie = ue - s - r)),
                i ? !El && xe(e) : Yl(),
                Ce(e);
            }),
            (document.onmouseup = () => {
              (document.onmousemove = o),
                (document.onmouseup = s),
                Yl(),
                (he.cols = we(z, he)),
                (he.rows = ve(G, he)),
                Q(n, 'drag--area'),
                I[T]('cell-area-selection-end', { rows: he.rows, cols: he.cols }, e);
            }),
            Z(n, 'drag--area'),
            Ce(e),
            (Rl.value = S),
            I[T]('cell-area-selection-start', t, e),
            I[T]('active-cell-change-end', { ...l, beforeActiveArea: y, activeArea: yl[$]() }, e);
        }
      }
      const {
          uniqueId: At,
          isNumber: Rt,
          browse: bt,
          assign: Et,
          slice: St,
          isBoolean: It,
          indexOf: yt,
          includes: Tt,
          eachTree: Dt,
          arrayEach: Vt,
          hasOwnProp: Ft,
          toInteger: $t,
          find: Bt,
          findLast: Mt,
          findLastIndexOf: Wt,
          findIndexOf: Lt,
          toNumber: kt,
          toValueString: Ot,
          toFormatString: Nt,
          filter: _t,
          some: Ht,
          get: Ut,
          set: Pt,
          first: Yt,
          last: Kt,
          isArray: Xt,
          toStringJSON: jt,
          template: qt,
        } = XEUtils,
        Gt = bt(),
        { modal: zt, t: Jt, config: Zt } = VXETable,
        { props: Qt, reactData: el, internalData: tl } = I,
        {
          computeSize: ll,
          computeEditOpts: ol,
          computeFNROpts: rl,
          computeClipOpts: nl,
          computeKeyboardOpts: al,
          computeSeqOpts: sl,
          computeMouseOpts: il,
          computeAreaOpts: cl,
          computeBodyMenu: dl,
          computeRowOpts: ul,
        } = I.getComputeMaps(),
        {
          refElem: fl,
          refLeftContainer: hl,
          refRightContainer: gl,
          refTableBody: ml,
          refTableLeftBody: pl,
          refTableRightBody: wl,
          refTableFooter: vl,
        } = I.getRefMaps(),
        Cl = ref({
          visible: !1,
          activeTab: '',
          findValue: '',
          replaceValue: '',
          isRE: !1,
          isWhole: !1,
          isSensitive: !1,
          showREErr: !1,
          showCount: !1,
          findCellRE: null,
          findCount: 0,
        }),
        xl = ref([]),
        Al = ref(null),
        Rl = ref([]),
        bl = [
          { value: 'find', label: 'vxe.pro.fnr.tabs.find' },
          { value: 'replace', label: 'vxe.pro.fnr.tabs.replace' },
        ];
      let El,
        Sl,
        Il = null,
        yl = {},
        Tl = {};
      const Dl = e[n('ZGVjb2RlVVJJQ29tcG9uZW50')];
      let Vl = 0;
      const Fl = [
          '%5Bv',
          'xe-ta',
          'ble%20',
          'v%7B%7',
          'B0%7D',
          '%7D%2',
          '0pro%20',
          '%7B%7B',
          '1%7D%7D',
          '%5D%2',
          '0Error%3A%',
          '7B%7B2%7D',
          '%7D%20%E6%',
          '9C%AA%E',
          '6%8E%88%E',
          '6%9',
          'D%83',
          '%E',
          'F%BC%8C%E',
          '5%A6%8',
          '2%E9%9C%80',
          '%E7%BB',
          '%A7%E7%',
          'BB%AD%E4%',
          'BD%BF%E',
          '7%94%A',
          '8%EF%BC%8C%',
          'E8%AF%B7%E5',
          '%88%B0%E',
          '5%AE%',
          '98%E7%B',
          'D%91',
          '%20ht',
          'tps%3',
          'A%2F%2Fvx',
          'etabl',
          'e.cn',
          '%2Fplug',
          'ins%2F%',
          '23%2Fpro',
          'Auth%20%E',
          '8%B4%AD%',
          'E4%B9%B0%E6',
          '%8E%88%E6%',
          '9D%83%E6%',
          '88%96%E8%',
          '81%94%E7%B3%',
          'BB%E9%82%AE',
          '%E4%BB%',
          'B6%20x_ex',
          'tends%',
          '40163.co',
          'm%20%E5',
          '%92%A8%',
          'E8%AF%A2',
        ],
        $l = [
          '%5Bvx',
          'e-ta',
          'ble%2',
          '0v%',
          '7B%7B',
          '0%7D%',
          '7D%20p',
          'ro%20%',
          '7B%7B1%',
          '7D%7D%5',
          'D%20Succ',
          'ess%3A%7B',
          '%7B2%',
          '7D%7D%EF',
          '%BC%8CA',
          'PI%EF%BC',
          '%9Ah',
          'ttps%3A',
          '%2F%2Fvx',
          'etabl',
          'e.cn%2F%',
          '23%2Fta',
          'ble%2Fapi',
          '%3Fq%3',
          'Dpro',
        ],
        Bl = function (e) {
          return e ? e.toLowerCase() : '';
        },
        Ml = (e) => e && !1 !== e.enabled,
        Wl = (e, t) => {
          const { key: l } = e;
          return (t = Bl(t)), t === Bl(l) || !!(g[l] && Bl(g[l]) === t);
        },
        Ll = (e, t) => e.type === t,
        kl = (e, t) => Lt(e, (e) => e.id === t.id),
        Ol = (e, t) => -1 < kl(e, t),
        Nl = (e, t) => I.findRowIndexOf(e, t),
        _l = (e, t) => -1 < Nl(e, t),
        Hl = (e) => (e === s ? 1 : e === i ? 2 : e === c ? 3 : e === d ? 4 : 0),
        Ul = (e) => I.getVTRowIndex(e),
        Pl = (e) => I.getVTColumnIndex(e),
        Yl = () => {
          clearTimeout(El), (El = null);
        },
        Kl = (e) => {
          e.preventDefault();
        },
        Xl = (e) => {
          e.stopPropagation(), Kl(e);
        },
        jl = (e, t) => e.querySelector(t),
        ql = (e) => e.getBoundingClientRect(),
        Gl = (e) => {
          e && (e.style.display = 'block');
        };
      let zl = 0;
      const Jl = '\t';
      let Zl;
      const Ql = (e, t) => {
          const l = Cl.value;
          l.activeTab !== t.value && ((l.activeTab = t.value), ct(), I[T]('fnr-change', { tab: l.activeTab }, e));
        },
        eo = (e, t) => {
          const { afterFullData: l, visibleColumn: o } = tl,
            r = l[t.row],
            n = o[t.col];
          r &&
            n &&
            (it(),
            (t.isActived = !0),
            I[W](r, n),
            yl[V]([{ type: a, startRow: r, endRow: r, startColumn: n, endColumn: n }]));
        },
        to = (e) => {
          const t = !1,
            l = Cl.value,
            o = yl[$](),
            r = Ot(l.findValue),
            n = Ot(l.replaceValue);
          if (rt(r) && (r || n))
            if (o) {
              const l = rl.value,
                { xegrid: a } = I,
                { beforeReplaceMethod: s, replaceMethod: i, afterReplaceMethod: c } = l,
                { row: d, column: u } = o;
              if (s && !1 === s({ isAll: t, findValue: r, replaceValue: n, $table: I, $grid: a })) return;
              nt(d, u, r)
                ? (i ? i({ row: d, column: u, cellValue: n }) : Pt(d, u.field, n),
                  dt(),
                  it(),
                  c &&
                    c({
                      isAll: t,
                      findValue: r,
                      replaceValue: n,
                      result: [{ row: d, _rowIndex: Ul(d), column: u, _columnIndex: Pl(u) }],
                      $table: I,
                      $grid: a,
                    }),
                  I[T]('fnr-replace', { findValue: r, replaceValue: n, row: d, column: u }, e))
                : zt && zt[y]({ message: Jt('vxe.pro.fnr.notCell'), status: 'warning', id: 'operWarn' });
            } else zt && zt[y]({ message: Jt('vxe.pro.fnr.notCell'), status: 'warning', id: 'operWarn' });
        },
        lo = (e) => {
          const { $event: t } = e,
            l = Wl(t, w);
          l && to(t);
        },
        oo = (e) => {
          const t = !0,
            l = Cl.value,
            o = rl.value,
            r = Ot(l.findValue),
            n = Ot(l.replaceValue);
          if (r || n) {
            const { xegrid: a } = I,
              { beforeReplaceMethod: s, replaceMethod: i, afterReplaceMethod: c } = o;
            if (l.showREErr) return;
            if (s && !1 === s({ isAll: t, findValue: r, replaceValue: n, $table: I, $grid: a })) return;
            const d = dt(!0);
            if ((it(), d.length)) {
              const l = [];
              Vt(d, (e) => {
                const { offsetRow: t, _rowIndex: o, offsetColumn: r, _columnIndex: a } = e;
                i ? i({ row: t, column: r, cellValue: n }) : Pt(t, r.field, n),
                  l.push({ row: t, _rowIndex: o, column: r, _columnIndex: a });
              }),
                c && c({ isAll: t, findValue: r, replaceValue: n, result: l, $table: I, $grid: a }),
                I[T]('fnr-replace-all', { findValue: r, replaceValue: n, result: l }, e),
                zt &&
                  zt[y]({ message: Jt('vxe.pro.fnr.replaceSuccess', [d.length]), status: 'success', id: 'operEnd' });
            } else zt && zt[y]({ message: Jt('vxe.pro.fnr.notCell'), status: 'warning', id: 'operWarn' });
          }
        },
        ro = (e) => {
          const t = !1,
            l = Cl.value,
            o = rl.value,
            { xegrid: r } = I,
            { beforeFindMethod: n, afterFindMethod: a } = o,
            s = Ot(l.findValue);
          if (!l.showREErr && !(n && !1 === n({ isAll: !1, findValue: s, $table: I, $grid: r }))) {
            const t = dt();
            if ((it(), !t.length))
              return void (zt && zt[y]({ message: Jt('vxe.pro.fnr.notCell'), status: 'warning', id: 'operWarn' }));
            const l = t[0];
            a &&
              a({
                isAll: !1,
                findValue: s,
                result: t.map((e) => ({
                  row: e.offsetRow,
                  _rowIndex: e._rowIndex,
                  column: e.offsetColumn,
                  _columnIndex: e._columnIndex,
                })),
                $table: I,
                $grid: r,
              }),
              I[T]('fnr-find', { findValue: s, row: l.offsetRow, column: l.offsetColumn }, e);
          }
        },
        no = (e) => {
          const { $event: t } = e,
            l = Cl.value,
            o = Wl(t, w);
          o && ('replace' === l.activeTab ? to(t) : ro(t));
        },
        ao = (e) => {
          const t = !0,
            l = Cl.value,
            o = rl.value,
            { xegrid: r } = I,
            { beforeFindMethod: n, afterFindMethod: a } = o,
            s = Ot(l.findValue);
          if (((xl.value = []), !l.showREErr) && !(n && !1 === n({ isAll: !0, findValue: s, $table: I, $grid: r }))) {
            const o = dt(!0);
            if (((l.findCount = o.length), (l.showCount = !0), o.length)) {
              const l = [],
                n = o.map((e, t) => {
                  const { offsetRow: o, offsetColumn: r, _rowIndex: n, _columnIndex: a } = e,
                    s = Ot(Ut(o, r.field)),
                    i = s || Jt('vxe.pro.fnr.empty');
                  return (
                    l.push({ row: o, _rowIndex: n, column: r, _columnIndex: a }),
                    { seq: t + 1, row: n, col: a, isActived: !1, value: i }
                  );
                });
              setTimeout(() => {
                (xl.value = n), a && a({ isAll: t, findValue: s, result: l, $table: I, $grid: r });
              }, 10),
                I[T]('fnr-find-all', { findValue: s, result: l }, e);
            } else zt && zt[y]({ message: Jt('vxe.pro.fnr.notCell'), status: 'warning', id: 'operWarn' });
          }
        },
        so = (e, t) => {
          const l = Cl.value,
            o = rl.value,
            r = Bt(bl, (e) => e.value === t) || bl[0];
          (('find' !== r.value || !o.isFind) && ('replace' !== r.value || !o.isReplace)) ||
            (ht(r), I[T]('open-fnr', { tab: l.activeTab }, e));
        },
        io = (e) => {
          const { afterFullData: t, visibleColumn: l } = tl;
          t.length &&
            l.length &&
            (Kl(e), yl[V]([{ type: a, startRow: Yt(t), endRow: Kt(t), startColumn: Yt(l), endColumn: Kt(l) }]));
        },
        co = (e, t) => {
          e.length &&
            I.recalculate().then(() => {
              const { afterFullData: l, visibleColumn: o } = tl,
                r = [];
              if (
                (Vt(e, (e) => {
                  const { type: t, cols: n, rows: a } = e,
                    s = Bt(n, (e) => Ol(o, e)),
                    i = Bt(a, (e) => _l(l, e));
                  if (i && s) {
                    const e = Mt(n, (e) => Ol(o, e)),
                      c = Mt(a, (e) => _l(l, e));
                    r.push({ type: t, startColumn: s, endColumn: e, startRow: i, endRow: c });
                  }
                }),
                r.length)
              ) {
                let l;
                t && (l = { area: r[yt(e, t.area)], row: t.row, column: t.column }), yl[V](r, l);
              } else yl[F]();
              if (Il) {
                const e = Il.cellAreas[0],
                  { cols: t, rows: r } = e,
                  n = Lt(t, (e) => Ol(o, e)),
                  a = Lt(r, (e) => _l(l, e));
                if (-1 < n && -1 < a) {
                  const s = Wt(t, (e) => Ol(o, e)),
                    i = Wt(r, (e) => _l(l, e));
                  (e.cols = St(t, n, s + 1)), (e.rows = St(r, a, i + 1));
                  const c = Ae(e);
                  Il = { cut: !1, cellAreas: c ? [c] : [] };
                }
              }
            });
        };
      let uo;
      (yl = {
        [B]() {
          return Rl.value || [];
        },
        [F](e) {
          const t = yl[B]();
          let l = e;
          if ((Rt(e) && (l = t[e]), l && 1 < t.length)) {
            const { el: e } = l,
              o = yl[$]();
            e && e.parentNode && e.parentNode.removeChild(e);
            const r = t.filter((e) => e !== l);
            if (((Rl.value = r), o && o.area === l)) {
              const e = Kt(r);
              yl[M]({ area: e, row: Kt(e.rows), column: Kt(e.cols) });
            }
          } else
            re((e) => {
              const t = e.children,
                l = t[0],
                o = t[2],
                r = t[3],
                n = t[4];
              if ((J(l), J(l.firstChild), J(o), J(n), r)) {
                const e = r.children;
                for (let t = e.length - 1; 0 <= t; t--) r.removeChild(e[t]);
              }
            }),
              (Al.value = null),
              (Rl.value = []);
          return nextTick();
        },
        getCopyCellArea() {
          return Il ? Il.cellAreas[0] : null;
        },
        getCopyCellAreas() {
          return Il ? Il.cellAreas : [];
        },
        [k]() {
          return ne(s), (Il = null), nextTick();
        },
        [V](e, t) {
          if (e) {
            Xt(e) || (e = [e]), yl[F]();
            let l = Bt(e, (e) => e.type === a),
              o = [];
            if ((l || ((l = Bt(e, (e) => !e.type)), l && (l.type = a)), l)) {
              const e = Re(l);
              o = e ? [e] : [];
            } else {
              const t = [];
              Vt(e, (e) => {
                const l = Re(e);
                l && t.push(l);
              }),
                (o = t);
            }
            if (o.length) {
              const l = o[0];
              let r,
                n,
                a = o[0];
              if (t) {
                const { area: s, row: i, column: c } = t;
                Rt(s) ? (a = o[s]) : s && (a = o[yt(e, s)] || l),
                  (r = Rt(i) ? a.rows[i] : i),
                  (n = Rt(c) ? a.cols[c] : c);
              }
              yl[M]({ area: a, row: r || Kt(a.rows), column: n || Kt(a.cols) });
            }
            Rl.value = o;
          }
          return nextTick();
        },
        [M](e) {
          return ne(d), (Al.value = be(Et({}, e, { type: d }))), nextTick();
        },
        [$]() {
          return Al.value || null;
        },
        openFind() {
          const e = rl.value;
          return e.isFind ? ht(bl[0]) : nextTick();
        },
        openReplace() {
          const e = rl.value;
          return e.isReplace ? ht(bl[1]) : nextTick();
        },
        closeFNR() {
          return Zl && Zl.close(), ut(), nextTick();
        },
        copyCellArea() {
          return _e(null);
        },
        cutCellArea() {
          return He(null);
        },
        pasteCellArea() {
          return Ue(null);
        },
      }),
        (Tl = {
          handleHeaderCellAreaEvent(e, t) {
            const { mouseConfig: l } = Qt,
              { afterFullData: o } = tl,
              { triggerFilter: r, column: n } = t,
              s = il.value,
              i = cl.value;
            l &&
              s.area &&
              (r
                ? yl[k]()
                : i.selectCellByHeader &&
                  (o.length
                    ? (I[O] ? I[O](e) : I[N](e),
                      setTimeout(() => {
                        const l = Yt(o),
                          r = [];
                        Dt(
                          [n],
                          (e) => {
                            (e.children && e.children.length) || r.push(e);
                          },
                          _,
                        );
                        const s = Yt(r),
                          i = Kt(r);
                        nextTick(() => {
                          yl[k](),
                            yl[V]([{ type: a, startColumn: s, endColumn: i, startRow: l, endRow: Kt(o) }], {
                              column: s,
                              row: l,
                            });
                        }),
                          I[W](l, s),
                          I[T]('header-cell-area-selection', Et({ targetRows: o.slice(0), targetCols: r }, t), e);
                      }, 10))
                    : (yl[F](), yl[k]())));
          },
          handleUpdateCellAreas() {
            const { scrollXLoad: e, scrollYLoad: t } = el,
              l = yl[B](),
              o = yl[$]();
            if (l.length && o) {
              const r = () => {
                co(l, o);
              };
              e || t ? (setTimeout(r, 40), setTimeout(r, 100)) : setTimeout(r, 0);
            }
          },
          handleKeyboardEvent(e) {
            gt(e);
          },
          handleCopyCellAreaEvent(e) {
            const t = nl.value;
            if (l && !1 !== t.isCopy && De()) {
              const t = e.clipboardData;
              if (t) {
                const l = Fe(e, !1),
                  { text: o, html: r, status: n } = l;
                t[D]('text/plain', o), t[D]('text/html', r), n && Ve(l, !1);
              }
            }
          },
          handleCutCellAreaEvent(e) {
            const t = nl.value;
            if (l && !1 !== t.isCut && De()) {
              const t = e.clipboardData;
              if (t) {
                const l = Fe(e, !0),
                  { text: o, html: r, status: n } = l;
                t[D]('text/plain', o), t[D]('text/html', r), n && Ve(l, !0);
              }
            }
          },
          handlePasteCellAreaEvent(e) {
            const t = nl.value;
            if (!1 !== t.isPaste && De()) {
              const t = e.clipboardData;
              if (t) {
                const l = t.getData('text/plain');
                l && Ne(e, { text: l });
              }
            }
          },
          triggerCellExtendMousedownEvent(e, t) {
            z() && Ct(e, t);
          },
          handleCellAreaEvent(e, t) {
            z() && xt(e, t);
          },
          triggerCopyCellAreaEvent(e) {
            z() && _e(e);
          },
          triggerCutCellAreaEvent(e) {
            z() && He(e);
          },
          triggerPasteCellAreaEvent(e) {
            z() && Ue(e);
          },
          triggerFNROpenEvent: so,
        });
      const fo = () => {
        if (!l) return (Vl = 80 * (50 * (Fl ? 1 : 2))), !1;
        const t = I[S] ? I[S]() : null,
          { key: r, m: a } = jt(Dl(n(o)));
        if (t && t['a' + (l ? '' : 'f') + 'ut' + (S ? '' : 'g') + 'hI' + (e ? '' : 't') + 'd'] !== r)
          return (Vl = 100 * (40.01 * (Fl ? 1 : 2))), !1;
        const s = U[n('aG9zdG5hbWU=')];
        if (!s) return (Vl = 6 * (667 * ($l ? 1 : 2))), !1;
        if (s === n('bG9jYWxob3N0') || s === n('MTI3LjAuMC4x')) return !0;
        if (X.test(s)) return !0;
        if (a) {
          if (a[0] === n('Kg==')) return !0;
          if (a.some((e) => e === s || new RegExp(`.${e}$`).test(s))) return !0;
        }
        return (Vl = 100 * (40.03 * ($l ? 1 : 2))), !1;
      };
      return (
        onMounted(() => {
          const e = fl.value,
            t = fo();
          r || (r = t), e && e.setAttribute(p, l), (m = t);
        }),
        onUnmounted(() => {
          const e = fl.value;
          e && e.removeAttribute(p), Zl && Zl.close();
        }),
        nextTick(() => {
          setTimeout(G, 3e3);
        }),
        { ...yl, ...Tl }
      );
    },
    setupGrid(e) {
      return e.extendTableMethods(H);
    },
  });
})();
